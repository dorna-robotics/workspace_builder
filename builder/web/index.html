<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dorna Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#f2f7fb;}
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <script type="module">

// --- DEBUG OVERLAY (auto) ---
(function(){
  const mk = () => {
    let el = document.getElementById("__ws_error_overlay");
    if (el) return el;
    el = document.createElement("div");
    el.id="__ws_error_overlay";
    el.style.cssText="position:fixed;left:0;right:0;bottom:0;max-height:45vh;overflow:auto;z-index:999999;background:#200;color:#fdd;font:12px/1.35 monospace;padding:10px;border-top:2px solid #f55;white-space:pre-wrap;";
    el.innerHTML="Workspace Builder crashed. Open DevTools console for full context.\n";
    document.body.appendChild(el);
    return el;
  };
  const show = (msg) => { try { mk().textContent += "\n" + msg; } catch(e){} };
  window.addEventListener("error", (e) => {
    const msg = (e?.error?.stack) ? e.error.stack : `${e.message} @ ${e.filename}:${e.lineno}:${e.colno}`;
    show(msg);
  });
  window.addEventListener("unhandledrejection", (e) => {
    const r = e.reason;
    const msg = (r && r.stack) ? r.stack : ("Unhandled rejection: " + String(r));
    show(msg);
  });
  console.log("[builder] debug overlay enabled");
})();
// --- END DEBUG OVERLAY ---

    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
    import io from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";

    // -------- cache-busting --------
    function versioned(url) {
      const v = (window.__CONFIG_VERSION__ || Date.now());
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${v}`;
    }
    async function getVersion() {
      try {
        const r = await fetch("/config_version", { cache: "no-store" });
        const j = await r.json();
        window.__CONFIG_VERSION__ = j?.version || String(Date.now());
      } catch {
        window.__CONFIG_VERSION__ = String(Date.now());
      }
    }

    async function boot() {
      // --- Scene / Camera / Renderer ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color("#f2f7fb");

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100000
      );
      camera.up.set(0,0,1);
      camera.position.set(1600, 600, 800);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 1.2;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = false;
      controls.target.set(0,0,0);
      controls.minDistance = 5;
      controls.maxDistance = 50000;

      // Pan mode: right-drag always pans; when panMode is ON, left-drag pans too.
      function applyPanMode(){
        controls.enablePan = true;
        controls.mouseButtons.LEFT = (window.builderState.panMode) ? THREE.MOUSE.PAN : THREE.MOUSE.ROTATE;
        controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
        controls.mouseButtons.MIDDLE = THREE.MOUSE.DOLLY;
      }

      // --- Environment (HDR) ---
      const pmrem = new THREE.PMREMGenerator(renderer);
      pmrem.compileEquirectangularShader();
      new RGBELoader().load(versioned("light.hdr"), (texture) => {
        const envScene = new THREE.Scene();
        const envMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.BackSide
        });
        const envGeo = new THREE.SphereGeometry(100, 64, 64);
        const envMesh = new THREE.Mesh(envGeo, envMaterial);
        envMesh.rotation.x = Math.PI / 2;
        envScene.add(envMesh);
        scene.environment = pmrem.fromScene(envScene).texture;
        scene.environmentIntensity = 0.1;
      });

      // --- Helpers (grid/axes) ---
      function makeRectGrid(width, height, step, major,
                            colorMinor = 0xaaaaaa,
                            colorMajor = 0xdddddd) {
        const geom = new THREE.BufferGeometry();
        const verts = [];
        const colors = [];
        const halfW = width / 2;
        const halfH = height / 2;
        const cMinor = new THREE.Color(colorMinor);
        const cMajor = new THREE.Color(colorMajor);

        for (let x = -halfW; x <= halfW + 1e-6; x += step) {
          const c = Math.abs(x % major) < 1e-6 ? cMajor : cMinor;
          verts.push(x, -halfH, 0,  x, halfH, 0);
          colors.push(c.r, c.g, c.b,  c.r, c.g, c.b);
        }
        for (let y = -halfH; y <= halfH + 1e-6; y += step) {
          const c = Math.abs(y % major) < 1e-6 ? cMajor : cMinor;
          verts.push(-halfW, y, 0,  halfW, y, 0);
          colors.push(c.r, c.g, c.b,  c.r, c.g, c.b);
        }

        geom.setAttribute("position",
          new THREE.Float32BufferAttribute(verts, 3));
        geom.setAttribute("color",
          new THREE.Float32BufferAttribute(colors, 3));

        return new THREE.LineSegments(
          geom,
          new THREE.LineBasicMaterial({ vertexColors: true, toneMapped: false })
        );
      }

      // grid: 3000 x 1000 (per your setting)
      scene.add(makeRectGrid(3000, 1000, 50, 500));

      function axisLine(start, end, color) {
        const geom = new THREE.BufferGeometry();
        geom.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(
            [start.x, start.y, start.z, end.x, end.y, end.z],
            3
          )
        );
        return new THREE.Line(
          geom,
          new THREE.LineBasicMaterial({ color, toneMapped: false })
        );
      }
      /*
      scene.add(axisLine(new THREE.Vector3(0,0,0),
                         new THREE.Vector3(1500,0,0), 0xff0000));
      scene.add(axisLine(new THREE.Vector3(0,0,0),
                         new THREE.Vector3(0,500,0), 0x00ff00));
      scene.add(axisLine(new THREE.Vector3(0,0,0),
                         new THREE.Vector3(0,0,500), 0x0000ff));
      */
      // --- Lights ---
      scene.add(new THREE.HemisphereLight(0xffffff, 0x222244, 0.3));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(1200, 900, 1500);
      scene.add(dir);

      // --- GLTF + object management ---
      const gltfLoader = new GLTFLoader();
      const objectsByName = new Map();
      window.objectsByName = objectsByName;

      function base64ToArrayBuffer(b64) {
        const bin = atob(b64);
        const len = bin.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = bin.charCodeAt(i);
        }
        return bytes.buffer;
      }

      function rodriguesDegToQuaternion(rx, ry, rz) {
        const ang = Math.hypot(rx, ry, rz);
        if (ang === 0) return new THREE.Quaternion();
        const ax = rx / ang;
        const ay = ry / ang;
        const az = rz / ang;
        const q = new THREE.Quaternion();
        q.setFromAxisAngle(new THREE.Vector3(ax, ay, az), ang * Math.PI / 180);
        return q;
      }
      window.rodriguesDegToQuaternion = rodriguesDegToQuaternion;

      // Convert a quaternion to a Rodrigues rotation vector in *degrees*.
      // A Rodrigues vector is axis * angle, where angle is in degrees.
      // This is the inverse of rodriguesDegToQuaternion (up to the usual
      // axis/angle sign ambiguity).
      function quaternionToRodriguesDeg(qIn) {
        const q = qIn.clone().normalize();
        // Clamp to avoid NaNs from acos.
        const w = Math.max(-1, Math.min(1, q.w));
        let angle = 2 * Math.acos(w); // radians, in [0, pi]
        const s = Math.sqrt(1 - w*w);
        let ax = 0, ay = 0, az = 0;
        if (s < 1e-8) {
          // If angle is ~0, axis is arbitrary.
          ax = 1; ay = 0; az = 0;
          angle = 0;
        } else {
          ax = q.x / s;
          ay = q.y / s;
          az = q.z / s;
        }
        const angleDeg = angle * 180 / Math.PI;
        return [ax * angleDeg, ay * angleDeg, az * angleDeg];
      }
      window.quaternionToRodriguesDeg = quaternionToRodriguesDeg;

      // ===== Picking + sticky anchor gizmos =====
      const raycaster = new THREE.Raycaster();
      const pointer   = new THREE.Vector2();
      const pickableMeshes = new Set();    // only meshes

      // Active binding:
      // { obj, items: [{name,pLocal,qLocal,axes,label}] }
      let activeAnchors = null;

      const anchorsLayer = new THREE.Group();
      anchorsLayer.frustumCulled = false;
      scene.add(anchorsLayer);

      function makeTextSprite(
        text,
        fontPx = 72,
        bg = "#000",
        fg = "#fff",
        alpha = 0.7,
        pad = 10,
        bold = true
      ) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        ctx.font = `${bold ? "bold " : ""}${fontPx}px sans-serif`;
        const metrics = ctx.measureText(text);
        canvas.width  = Math.ceil(metrics.width + pad * 2);
        canvas.height = Math.ceil(fontPx + pad * 2);

        ctx.font = `${bold ? "bold " : ""}${fontPx}px sans-serif`;
        ctx.textAlign = "left";
        ctx.textBaseline = "top";

        ctx.fillStyle = bg;
        ctx.globalAlpha = alpha;
        ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = fg;
        ctx.fillText(text, pad, pad);

        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;

        const mat = new THREE.SpriteMaterial({
          map: tex,
          depthTest: false
        });
        const spr = new THREE.Sprite(mat);

        const scale = 0.1;
        spr.scale.set(canvas.width * scale, canvas.height * scale, 1);
        spr.renderOrder = 999;
        spr.frustumCulled = false;
        return spr;
      }

      function makeAxesHelperAlwaysOnTop(size) {
        const axes = new THREE.AxesHelper(size);
        axes.traverse(child => {
          if (child.material && child.material.isMaterial) {
            child.material.depthTest = false;
            child.renderOrder = 999;
          }
        });
        axes.renderOrder = 999;
        axes.frustumCulled = false;
        return axes;
      }

      // ---- CLEAR ANCHORS (updated: also hides bottom-left UI) ----
      function clearAnchors() {
        if (activeAnchors) {
          activeAnchors.items.forEach(it => {
            anchorsLayer.remove(it.axes);
            if (it.label) anchorsLayer.remove(it.label);
          });
        }
        activeAnchors = null;

        const bar = document.getElementById("infoBar");
        if (bar) {
          bar.style.display = "none";
        }
      }

      // ---- BUILD ANCHORS (updated: uses bottom-left UI for Name/Type/Solid) ----
      function buildAnchorsFor(obj) {
        clearAnchors();

        // Support both legacy `anchors` and newer multi-solid `anchorsBySolid` storage.
        // IMPORTANT: for multi-solid assemblies (like core), show anchors for ALL solids,
        // not just the current/active one (otherwise you only see e.g. A0).
        const ud = obj?.userData || {};
        const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;

        // Convert an anchor defined in a solid's local frame into the root component's local frame.
        function __solidAnchorToRoot(obj, solidKey, pLocal, qLocal) {
          try {
            if (!solidKey) return { p: pLocal, q: qLocal };
            const holder = obj.getObjectByName ? obj.getObjectByName(String(solidKey)) : null;
            if (!holder || holder === obj) return { p: pLocal, q: qLocal };
            // Position: holderLocal -> world -> objLocal
            const pW = holder.localToWorld(pLocal.clone());
            const pRoot = obj.worldToLocal(pW.clone());
            // Orientation: holderLocal -> world -> objLocal
            const hW = new THREE.Quaternion();
            const oW = new THREE.Quaternion();
            holder.getWorldQuaternion(hW);
            obj.getWorldQuaternion(oW);
            const qW = hW.clone().multiply(qLocal);
            const qRoot = oW.clone().invert().multiply(qW);
            return { p: pRoot, q: qRoot };
          } catch (e) {
            return { p: pLocal, q: qLocal };
          }
        }

        // Build a flat list of anchors to display.
        // Each entry can optionally carry a `solidKey` for correct snapping when clicked.
        const flat = [];

        // 1) If anchorsBySolid exists with multiple solids, show all.
        if (ab && Object.keys(ab).length) {
          const solidKeys = Object.keys(ab);
          for (const solidKey of solidKeys) {
            const anchors = ab[solidKey] || {};
            for (const [name, arr] of Object.entries(anchors)) {
              if (!Array.isArray(arr) || arr.length !== 6) continue;
              flat.push({ solidKey, name, arr });
            }
          }
        } else {
          // 2) Legacy anchors
          const anchors = (ud.anchors && typeof ud.anchors === "object") ? ud.anchors : {};
          for (const [name, arr] of Object.entries(anchors)) {
            if (!Array.isArray(arr) || arr.length !== 6) continue;
            flat.push({ solidKey: null, name, arr });
          }
        }

        if (!flat.length) return;

        // De-dupe display names (same anchor names across different solids like "center").
        // Prefer prefixing with solidKey when needed.
        const nameCounts = new Map();
        for (const it of flat) {
          const k = String(it.name);
          nameCounts.set(k, (nameCounts.get(k) || 0) + 1);
        }

        const items = [];
        for (const it of flat) {
          const { solidKey, name, arr } = it;
          const [ax, ay, az, rx, ry, rz] = arr;
          const pSolid = new THREE.Vector3(ax, ay, az);
          const qSolid = rodriguesDegToQuaternion(rx, ry, rz);
          const xform = __solidAnchorToRoot(obj, solidKey, pSolid, qSolid);
          const pLocal = xform.p;
          const qLocal = xform.q;

          const displayName = (solidKey && (nameCounts.get(String(name)) || 0) > 1)
            ? `${solidKey}:${name}`
            : String(name);

          const size = 18;
          const axes = makeAxesHelperAlwaysOnTop(size);
          const label = makeTextSprite(displayName, 90, "#000", "#fff", 0.65);

          anchorsLayer.add(axes);
          anchorsLayer.add(label);

          // clickable (nearly invisible) pick sphere
          const pickGeo = new THREE.SphereGeometry(6, 12, 12);
          const pickMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.02, depthTest: false });
          const pick = new THREE.Mesh(pickGeo, pickMat);
          pick.renderOrder = 998;
          pick.frustumCulled = false;
          pick.userData.__isAnchorPick = true;
          pick.userData.anchorName = name;
          pick.userData.ownerName = obj?.name || "";
          // For multi-solid assemblies, record which solid this anchor belongs to.
          if (solidKey) pick.userData.solidKey = solidKey;
          anchorsLayer.add(pick);

          // register for raycast picking
          pickableMeshes.add(pick);

          items.push({ name: displayName, rawName: name, solidKey, pLocal, qLocal, axes, label, pick });
        }

        // Extract data
        const comp  = obj.userData?.componentName || "--";
        const type  = obj.userData?.typeName      || obj.userData?.type || "--";
        const solid = obj.userData?.solidName     || (ab ? "multi" : "--");

        // Update bottom-left display
        const bar = document.getElementById("infoBar");
        const nameEl  = document.getElementById("infoName");
        const typeEl  = document.getElementById("infoType");
        const solidEl = document.getElementById("infoSolid");

        if (nameEl)  nameEl.textContent  = `Name: ${comp}`;
        if (typeEl)  typeEl.textContent  = `Type: ${type}`;
        if (solidEl) solidEl.textContent = `Solid: ${solid}`;
        if (bar)     bar.style.display   = "flex";

        activeAnchors = { obj, items };
        updateAnchorsNow(); // position immediately once
      }

      // ---- UPDATE ANCHORS (updated: no 3D comp/solid labels anymore) ----
      function updateAnchorsNow() {
        if (!activeAnchors) return;
        const { obj, items } = activeAnchors;
        if (!obj.parent) {
          clearAnchors();
          return;
        }

        const objWorldQ = new THREE.Quaternion();
        obj.getWorldQuaternion(objWorldQ);

        for (const it of items) {
          const pWorld = obj.localToWorld(it.pLocal.clone());
          const qWorld = objWorldQ.clone().multiply(it.qLocal);
          it.axes.position.copy(pWorld);
          it.axes.quaternion.copy(qWorld);
          if (it.pick) { it.pick.position.copy(pWorld); it.pick.quaternion.copy(qWorld); }
          if (it.label) {
            it.label.position.copy(pWorld).add(new THREE.Vector3(0,0,22));
          }
        }
      }

      function setPointerFromEvent(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width)  * 2 - 1;
        pointer.y = ((event.clientY - rect.top)  / rect.height) * -2 + 1;
      }

      // Anchor "hit zones" (nearly-invisible spheres) are useful when the user is
      // explicitly picking anchors (joints / pattern second anchor, etc.).
      // But they should NOT steal clicks during normal object selection.
      function wantAnchorHitZones() {
        const m = window.builderState?.mode || "IDLE";
        // Only allow clicking the anchor hit-zones when we're in a mode that
        // expects an anchor click.
        return (
          m === "PICK_TARGET_ANCHOR" ||
          m === "PICK_CHILD_ANCHOR" ||
          m === "RECTPATTERN_PICK_SECOND_ANCHOR" ||
          // any future modes can opt-in by containing "_ANCHOR"
          (typeof m === "string" && m.includes("_ANCHOR"))
        );
      }

      function pickFirstMesh() {
        raycaster.setFromCamera(pointer, camera);
        const targets = pickableMeshes.size
          ? Array.from(pickableMeshes)
          : scene.children;
        const hits = raycaster.intersectObjects(targets, true);
        if (!hits.length) return null;

        const allowAnchor = wantAnchorHitZones();
        for (const h of hits) {
          if (!h.object?.isMesh) continue;
          const isAnchorPick = !!(h.object.userData && h.object.userData.__isAnchorPick);
          if (isAnchorPick && !allowAnchor) continue;
          return h;
        }
        return null;
      }

      // ---- Quick-click filter (left button only) ----
      const CLICK_MS = 250;
      const CLICK_PX = 6;
      let downInfo = null; // {button,x,y,time}

      renderer.domElement.addEventListener("pointerdown", (e) => {
        downInfo = {
          button: e.button,
          x: e.clientX,
          y: e.clientY,
          time: performance.now()
        };
        if (e.button === 2) {
          e.preventDefault();
          clearAnchors();
        }
      });

      renderer.domElement.addEventListener("pointerup", (e) => {
        if (!downInfo) return;
        const dt = performance.now() - downInfo.time;
        const dx = Math.abs(e.clientX - downInfo.x);
        const dy = Math.abs(e.clientY - downInfo.y);
        const moved = (dx > CLICK_PX || dy > CLICK_PX);

        if (downInfo.button === 0 &&
            e.button === 0 &&
            dt <= CLICK_MS &&
            !moved) {
          setPointerFromEvent(e);
          const hit = pickFirstMesh();
          if (hit && hit.object?.isMesh) {
            // RectPattern: interactive selection (object + second point) handled here
            // ----------------------------
            // Rectangular Pattern: pick seed object
            // ----------------------------
            if (window.builderState?.mode === "RECTPATTERN_PICK_OBJECT") {
              try {
                // Robustly resolve the clicked mesh to a builder component root.
                const name = (function(){
                  let o = hit.object;
                  while (o) {
                    const cand = (o.userData && o.userData.componentName) ? o.userData.componentName : o.name;
                    if (cand && ((objectsByName && objectsByName.has && objectsByName.has(cand)) || (window.builderState && window.builderState.components && window.builderState.components[cand]))) return cand;
                    o = o.parent;
                  }
                  return null;
                })();
                const ui = window.builderState.rectPatternUi;
                if (!name || !ui) { showToast("Select a valid object."); downInfo=null; return; }

                // Determine whether object is anchored (attach metadata may be in builderState or in userData)
                const meta = (window.builderState.components && window.builderState.components[name]) ? window.builderState.components[name] : null;
                const obj = objectsByName.get(name);
                const attach = meta?.attach || obj?.userData?.builderAttach || obj?.userData?.attach || null;

                // Anchor A strategy:
                // - If object is anchored and we can read that anchor => use it.
                // - Otherwise allow free objects too (including ones created by a previous pattern)
                //   and use the object's current world position as Anchor A.
                let aWorld = null;
                let aOwner = null;
                let aName = null;
                const hasAttach = !!(attach && attach.parent_name && attach.parent_anchor);
                if (hasAttach) {
                  aWorld = __rpAnchorWorldPose(attach.parent_name, attach.parent_anchor);
                  if (aWorld && aWorld.pos) {
                    aOwner = attach.parent_name;
                    aName = attach.parent_anchor;
                  } else {
                    // If attach exists but anchor isn't readable, fall back to free mode.
                    aWorld = null;
                  }
                }

                // Store seed world pose and the offset from Anchor A to the seed object.
                const seedWorldPos = new THREE.Vector3();
                const seedWorldQuat = new THREE.Quaternion();
                obj.getWorldPosition(seedWorldPos);
                obj.getWorldQuaternion(seedWorldQuat);
                const aPos = (aWorld && aWorld.pos) ? aWorld.pos.clone() : seedWorldPos.clone();
                const seedOffset = seedWorldPos.clone().sub(aPos);

                window.builderState.rectPattern = {
                  seedName: name,
                  seedType: (meta && meta.type) ? meta.type : (obj?.userData?.typeName || ""),
                  seedOptions: (function(){
                    const o = (meta && typeof meta === "object") ? Object.assign({}, meta) : {};
                    delete o.type; delete o.attach;
                    return o;
                  })(),
                  childAnchor: (attach && attach.child_anchor) ? attach.child_anchor : "center",
                  seedWorldQuat,
                  attach: hasAttach ? attach : null,
                  aAnchor: {
                    ownerName: aOwner,
                    anchorName: aName,
                    pos: aPos.clone()
                  },
                  seedOffset,
                  bAnchor: null,
                  delta: null,
                  secondOwnerName: null
                };

                ui.seedName = name;
                ui.seedBox.dataset.state = "ok";
                ui.seedBox.textContent = hasAttach ? `${name} ✓` : `${name} ✓ (free)`;
                ui.seedBox.style.borderColor = "rgba(0,140,0,0.55)";
                ui.seedBox.style.background = "rgba(0,140,0,0.08)";
                ui.seedClear.style.display = "inline-flex";

                // reset point box
                ui.pointBox.dataset.state = "empty";
                ui.pointBox.textContent = "Select 2nd anchor…";
                ui.pointBox.style.borderColor = "rgba(0,0,0,0.18)";
                ui.pointBox.style.background = "rgba(0,0,0,0.02)";
                ui.pointClear.style.display = "none";

                window.builderState.mode = "IDLE";
                try { window.hideBanner(); } catch(e) {}
                if (!hasAttach) {
                  showToast("Seed set (free object). Now pick 2nd anchor.");
                } else if (!aWorld) {
                  showToast("Seed set (anchor unreadable, using current pose). Now pick 2nd anchor.");
                } else {
                  showToast("Seed set. Now pick 2nd anchor.");
                }
                downInfo=null;
                return;
              } catch (e) {
                console.error(e);
                showToast("RectPattern error: " + (e?.message||e));
                window.builderState.mode = "IDLE";
                try { window.hideBanner(); } catch(e) {}
                downInfo=null;
                return;
              }
            }

            // ----------------------------
            // Rectangular Pattern: pick 2nd anchor (first pick object, then pick anchor)
            // ----------------------------
            if (window.builderState?.mode === "RECTPATTERN_PICK_SECOND_OBJECT") {
              try {
                const rp = window.builderState.rectPattern;
                const ui = window.builderState.rectPatternUi;
                if (!rp || !ui || !rp.seedName) { showToast("Pick a seed object first."); downInfo=null; return; }

                const targetName = (function(){
                  let o = hit.object;
                  while (o) {
                    const cand = (o.userData && o.userData.componentName) ? o.userData.componentName : o.name;
                    if (cand && ((objectsByName && objectsByName.has && objectsByName.has(cand)) || (window.builderState && window.builderState.components && window.builderState.components[cand]))) return cand;
                    o = o.parent;
                  }
                  return null;
                })();
                if (!targetName) { showToast("Select a valid target object."); downInfo=null; return; }

                rp.secondOwnerName = targetName;
                window.builderState.mode = "RECTPATTERN_PICK_SECOND_ANCHOR";
                try { window.showBanner?.("Now click an anchor on the target object."); } catch(e) {}
                try {
                  const root = objectsByName.get(targetName);
                  if (root) buildAnchorsFor(root);
                } catch(e) {}

                // Update UI (object chosen, anchor pending)
                ui.pointBox.dataset.state = "empty";
                ui.pointBox.textContent = `Target: ${targetName} (pick anchor…)`;
                ui.pointBox.style.borderColor = "rgba(0,0,0,0.18)";
                ui.pointBox.style.background = "rgba(0,0,0,0.02)";
                ui.pointClear.style.display = "inline-flex";

                // Enable the anchor list chooser
                if (ui.anchorListBtn) {
                  ui.anchorListBtn.disabled = false;
                  ui.anchorListBtn.style.opacity = "1";
                }

                downInfo=null;
                return;
              } catch (e) {
                console.error(e);
                showToast("RectPattern error: " + (e?.message||e));
                window.builderState.mode = "IDLE";
                try { window.hideBanner(); } catch(e) {}
                downInfo=null;
                return;
              }
            }

            // (Legacy free-point mode kept for safety but not used by the UI)
            if (window.builderState?.mode === "RECTPATTERN_PICK_SECOND") {
              try {
                const rp = window.builderState.rectPattern;
                const ui = window.builderState.rectPatternUi;
                if (!rp || !ui || !rp.aPos) { showToast("Pick a seed object first."); downInfo=null; return; }

                const bPos = hit.point.clone();
                rp.bPos = bPos;
                rp.delta = bPos.clone().sub(rp.aPos);

                // Update UI
                ui.pointBox.dataset.state = "ok";
                ui.pointBox.textContent = `2nd point ✓ (${bPos.x.toFixed(2)}, ${bPos.y.toFixed(2)}, ${bPos.z.toFixed(2)})`;
                ui.pointBox.style.borderColor = "rgba(0,140,0,0.55)";
                ui.pointBox.style.background = "rgba(0,140,0,0.08)";
                ui.pointClear.style.display = "inline-flex";

                // Disable axes with ~0 delta
                const eps = 1e-6;
                const dx = rp.delta.x, dy = rp.delta.y, dz = rp.delta.z;
                ui.nx.disabled = Math.abs(dx) < eps;
                ui.ny.disabled = Math.abs(dy) < eps;
                ui.nz.disabled = Math.abs(dz) < eps;
                if (ui.nx.disabled) ui.nx.value = "1";
                if (ui.ny.disabled) ui.ny.value = "1";
                if (ui.nz.disabled) ui.nz.value = "1";
                if (ui.hint) ui.hint.textContent = `Δ = (${dx.toFixed(2)}, ${dy.toFixed(2)}, ${dz.toFixed(2)}).`;

                window.builderState.mode = "IDLE";
                try { window.hideBanner(); } catch(e) {}
                showToast("2nd point set.");
                downInfo=null;
                return;
              } catch (e) {
                console.error(e);
                showToast("RectPattern error: " + (e?.message||e));
                window.builderState.mode = "IDLE";
                try { window.hideBanner(); } catch(e) {}
                downInfo=null;
                return;
              }
            }

if (hit.object.userData && hit.object.userData.__isAnchorPick) {
              // Route anchor clicks based on current builder mode
              if (window.builderState?.mode === "RECTPATTERN_PICK_SECOND_ANCHOR") {
                try { rectPatternHandleSecondAnchor(hit.object.userData.ownerName, hit.object.userData.anchorName); } catch (e) { console.error(e); showToast("RectPattern error: " + (e?.message||e)); }
              } else {
                handleAnchorPick(hit.object.userData.ownerName, hit.object.userData.anchorName, hit.object.userData.solidKey || null);
              }
              downInfo = null;
              return;
            }
            // Resolve clicked mesh to a builder component root reliably (works for nested/anchored objects)
            const resolvedName = (function(){
              let o = hit.object;
              while (o) {
                const cand = (o.userData && o.userData.componentName) ? o.userData.componentName : o.name;
                if (cand && ((objectsByName && objectsByName.has && objectsByName.has(cand)) || (window.builderState && window.builderState.components && window.builderState.components[cand]))) return cand;
                o = o.parent;
              }
              return null;
            })();
            let node = resolvedName ? objectsByName.get(resolvedName) : null;
            const compName = resolvedName;
            if (!node || !compName) { showToast("Select a valid object."); downInfo=null; return; }
if (node) {
              if (window.builderState.mode === "PICK_TARGET_OBJECT" && window.builderState.pending) {
  window.builderState.targetName = compName;
  window.builderState.mode = "PICK_TARGET_ANCHOR";
  // Show searchable list of anchors for the chosen target (pattern-style).
  try { openTargetAnchorMenu(compName); } catch(e) { console.warn(e); }
  showToast("Pick a target anchor (click in 3D or use the list).");
}

              if (window.builderState.mode === "PATTERN_PICK_SOURCE_OBJECT" && window.builderState.pattern) {
                const srcName = compName;
                if (srcName === window.builderState.pattern.plateName) {
                  showToast("Invalid: cannot pattern the plate into itself.");
                } else {
                  // anchorsBySolid: prefer full mapping if available
                  const ab = node.userData.anchorsBySolid || { "solid_0": (node.userData.anchors || {}) };
                  openPatternSourceAnchorMenu(srcName, ab);
                  showToast("Choose the source anchor to place into each hole.");
                }
              }
	buildAnchorsFor(node);

	// While mid-joint, keep the *pending child* as the primary selection.
	// We still allow clicking other objects to inspect anchors/joints,
	// but Delete/Cancel should always refer to the object being jointed.
	if ((window.builderState.mode === "PICK_TARGET_OBJECT" || window.builderState.mode === "PICK_TARGET_ANCHOR") && window.builderState.pending?.name) {
	  try { setSelected(window.builderState.pending.name); } catch(e) {}
	}
            }
              if (window.builderState.mode === "IDLE") { const sel = compName; if (sel) setSelected(sel); }

          }
        }
        downInfo = null;
      });

      renderer.domElement.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      renderer.domElement.addEventListener("pointermove", (e) => {
        setPointerFromEvent(e);
        const hit = pickFirstMesh();
        renderer.domElement.style.cursor =
          (hit && hit.object?.isMesh) ? "pointer" : "default";
      });

      function registerPickables(node) {
        node.traverse(o => {
          if (o.isMesh) pickableMeshes.add(o);
        });
      }


      function unregisterPickables(node) {
        node.traverse(o => {
          if (o.isMesh) pickableMeshes.delete(o);
        });
      }

      function disposeNode(node) {
        node.traverse(o => {
          if (!o.isMesh) return;
          if (o.geometry) { try { o.geometry.dispose(); } catch(e) {} }
          const mat = o.material;
          if (Array.isArray(mat)) {
            for (const m of mat) { if (m && m.dispose) { try { m.dispose(); } catch(e) {} } }
          } else if (mat && mat.dispose) {
            try { mat.dispose(); } catch(e) {}
          }
        });
      }

      // ---- Add edge overlay to all meshes (updated: uses userData) ----
      function addEdgeOverlay(node) {
        node.traverse(obj => {
          if (!obj.isMesh) return;

          // store original
          if (!obj.userData.__originalMat) {
            obj.userData.__originalMat = obj.material;
          }
          obj.material = obj.userData.__originalMat;

          // remove old if exists
          if (obj.userData.__edgeLines) {
            obj.remove(obj.userData.__edgeLines);
            obj.userData.__edgeLines.geometry.dispose();
            obj.userData.__edgeLines.material.dispose();
            obj.userData.__edgeLines = null;
          }

          // add new edge overlay
          const edgesGeo = new THREE.EdgesGeometry(obj.geometry, 30);
          const edgesMat = new THREE.LineBasicMaterial({
            color: 0x000000,
            toneMapped: false
          });
          const edgeLines = new THREE.LineSegments(edgesGeo, edgesMat);
          edgeLines.renderOrder = 10;
          obj.add(edgeLines);
          obj.userData.__edgeLines = edgeLines;
        });
      }

      // --- upsert pipeline ---
      function upsertObject(name, spec) {
        if (spec.delete) {
          const prev = objectsByName.get(name);
          if (prev) {
            if (activeAnchors &&
                (activeAnchors.obj === prev ||
                 (prev.isAncestorOf && prev.isAncestorOf(activeAnchors.obj)))) {
              clearAnchors();
            }
            prev.traverse(o => {
              if (o.isMesh) pickableMeshes.delete(o);
            });
            scene.remove(prev);
            objectsByName.delete(name);
            try { delete window.builderState.specs[name]; } catch (e) {}
          }
          return;
        }

        // Track last known spec so Undo/Redo can replay exact state.
        try {
          const prev = window.builderState.specs[name] || {};
          // merge shallow (pose/anchors/meshes etc are replaced atomically)
          window.builderState.specs[name] = __deepClone(Object.assign({}, prev, spec));
        } catch (e) {}

        let root = objectsByName.get(name);
        if (!root) {
          root = new THREE.Group();
          root.name = name;
          root.userData = root.userData || {};
          root.userData.componentName = name;

          scene.add(root);
          objectsByName.set(name, root);
        }

        // Multi-mesh support (simulation-style assemblies)
        // spec.meshes: [{ meshUrl, pose:[x,y,z,a,b,c], solidName }]
        if (Array.isArray(spec.meshes) && spec.meshes.length) {
          const sig = JSON.stringify(spec.meshes.map(m => [m.meshUrl, ...(m.pose||[]), m.solidName||""]));
          if (root.userData.meshesSig !== sig) {
            root.userData.meshesSig = sig;
            root.userData.meshUrl = null;

            // clear old children
            while (root.children.length) {
              root.children[0].traverse(o => { if (o.isMesh) pickableMeshes.delete(o); });
              root.remove(root.children[0]);
            }

            for (const m of spec.meshes) {
              if (!m || !m.meshUrl) continue;
              const holder = new THREE.Group();
              holder.name = m.solidName ? String(m.solidName) : "solid";
              if (Array.isArray(m.pose) && m.pose.length === 6) {
                const [x,y,z,rx,ry,rz] = m.pose;
                holder.position.set(x,y,z);
                holder.quaternion.copy(rodriguesDegToQuaternion(rx,ry,rz));
              }
              root.add(holder);

              gltfLoader.load(
                versioned(m.meshUrl),
                (gltf) => {
                  gltf.scene.traverse(o => {
                    if (o.isMesh) {
                      const mats = Array.isArray(o.material) ? o.material : [o.material];
                      mats.forEach(mat => { if (mat && "side" in mat) mat.side = THREE.DoubleSide; });
                    }
                  });
                  addEdgeOverlay(gltf.scene);
                  try { gltf.scene.traverse(o=>{ if(!o.userData) o.userData={}; o.userData.componentName = name; }); } catch(e) {}
                  holder.add(gltf.scene);
                  registerPickables(gltf.scene);
                },
                undefined,
                () => { /* ignore */ }
              );
            }
          }
        }

        // Single mesh support
        if (!spec.meshes && spec.meshUrl) {
          if (!root.userData.meshUrl || root.userData.meshUrl !== spec.meshUrl) {
            root.userData.meshUrl = spec.meshUrl;
            root.userData.meshesSig = null;

            // clear old children
            while (root.children.length) {
              root.children[0].traverse(o => {
                if (o.isMesh) pickableMeshes.delete(o);
              });
              root.remove(root.children[0]);
            }

            gltfLoader.load(
              versioned(spec.meshUrl),
              (gltf) => {
                gltf.scene.traverse(o => {
                  if (o.isMesh) {
                    const mats = Array.isArray(o.material) ? o.material : [o.material];
                    mats.forEach(m => { if (m && "side" in m) m.side = THREE.DoubleSide; });
                  }
                });

                addEdgeOverlay(gltf.scene);

                // Tag all child nodes so click-picking can resolve back to the component root.
                // Multi-mesh loads already do this; single-mesh loads must too.
                try {
                  gltf.scene.traverse(o => {
                    if (!o.userData) o.userData = {};
                    o.userData.componentName = name;
                  });
                } catch (e) {}

                root.add(gltf.scene);
                registerPickables(gltf.scene);
              },
              undefined,
              () => { /* ignore errors for now */ }
            );
          }
        }

        // Also support optional base64 GLB "mesh" (not used by current Display)
        if (spec.mesh) {
          const buf = base64ToArrayBuffer(spec.mesh);
          gltfLoader.parse(
            buf, "",
            (gltf) => {
              while (root.children.length) {
                root.children[0].traverse(o => { if (o.isMesh) pickableMeshes.delete(o); });
                root.remove(root.children[0]);
              }

              gltf.scene.traverse(o => {
                if (o.isMesh) {
                  const mats = Array.isArray(o.material) ? o.material : [o.material];
                  mats.forEach(m => { if (m && "side" in m) m.side = THREE.DoubleSide; });
                }
              });

              addEdgeOverlay(gltf.scene);   // <<<<<< ADD THIS

              // Tag all child nodes so click-picking can resolve back to the component root.
              try {
                gltf.scene.traverse(o => {
                  if (!o.userData) o.userData = {};
                  o.userData.componentName = name;
                });
              } catch (e) {}

              root.add(gltf.scene);
              registerPickables(gltf.scene);
            },
            () => { /* ignore parse errors */ }
          );
        }

        if (Array.isArray(spec.pose) && spec.pose.length === 6) {
          const [x, y, z, rx, ry, rz] = spec.pose;
          root.position.set(x, y, z);
          root.quaternion.copy(rodriguesDegToQuaternion(rx, ry, rz));
        }

        if (typeof spec.visible === "boolean") {
          root.visible = spec.visible;
        }

        if (spec.anchors && typeof spec.anchors === "object") {
          root.userData.anchors = spec.anchors;
        }
	        // NEW: preserve multi-solid anchors (required for plates and many assemblies)
	        if (spec.anchorsBySolid && typeof spec.anchorsBySolid === "object") {
	          root.userData.anchorsBySolid = spec.anchorsBySolid;
	        }

        // NEW: preserve builder attach metadata from server/config
        if (spec.builder && spec.builder.attach && typeof spec.builder.attach === "object") {
          root.userData.builderAttach = spec.builder.attach;
          try {
            try {
              // Keep builder state synced when objects are injected/updated from upstream.
              // Never clobber an existing type/options; only fill missing pieces.
              const __cur = window.builderState.components[name] || {};
              const __t = __cur.type || root.userData.typeName || spec.typeName;
              window.builderState.components[name] = Object.assign({}, __cur, (__t ? { type: __t } : {}), { attach: spec.builder.attach });
            } catch (e) {}
          } catch (e) {}
        }

        if (spec.componentName) {
          root.userData.componentName = spec.componentName;
        }
        if (spec.solidName) {
          root.userData.solidName = spec.solidName;
        }
        // NEW: store type/typeName so the UI can display it
        if (spec.typeName) {
          root.userData.typeName = spec.typeName;
        }
        if (spec.type) {
          root.userData.typeName = spec.type;
        }
      }

      // --- Socket.IO hookup ---
      const socket = io({
        path: "/socket.io/",
        transports: ["websocket"],
        forceNew: true,
        timeout: 10000
      });

      // Expose socket for actions outside boot()
      window.socket = socket;

      socket.on("scene_update", (payload) => {
        if (!payload || typeof payload !== "object") return;
        for (const [n, s] of Object.entries(payload)) {
          upsertObject(n, s || {});
      window.upsertObject = upsertObject;
        }
      });

// =========================
// Builder (insert + snap + save config)
// =========================
const builderState = {
  next: { fixture_plate: 1, sbs_adapter: 1 },
  lastFixturePlate: null,
  placedOrder: [],
  selectedName: null,
  mode: "IDLE", // IDLE | PICK_TARGET_OBJECT | PICK_TARGET_ANCHOR
  pending: null, // { name, type, sourceAnchor, childSolid }
  targetName: null,
  components: {}, // name -> {type, attach?, offset?}
  panMode: false,

  // --- Undo / Redo ---
  // We track atomic actions (create, attach, pattern-batch) so:
  // - undo attach => object remains, becomes unanchored
  // - undo again => deletes created object (if it was created last)
  // - undo pattern => deletes all created instances from that pattern run
  undoStack: [],
  redoStack: [],
  // Keep last known scene spec for each object (what we send to upsertObject)
  specs: {}
  ,suspendUndo: false
};
window.builderState = builderState;

// Simple deep-clone for small JSON-like objects
function __deepClone(obj) {
  try { return JSON.parse(JSON.stringify(obj)); } catch (e) { return obj; }
}

// -----------------
// Undo / Redo stack
// -----------------
function __pushUndo(action) {
  try {
    if (window.builderState.suspendUndo) return;
    if (!action) return;
    window.builderState.undoStack.push(action);
    window.builderState.redoStack.length = 0; // clear redo on new action
  } catch (e) {}
}

// Push an undo action even if suspendUndo is currently true (used for atomic operations like pattern).
function __pushUndoForce(action) {
  try {
    if (!action) return;
    const st = window.builderState;
    st.undoStack.push(action);
    st.redoStack.length = 0;
  } catch (e) {}
}

// Merge a just-created object + its first attach into a single atomic action.
// Desired behavior:
// - Spawn -> Joint -> Undo  => deletes the object (not just un-attach)
// - Redo restores it with the joint.
function __maybeMergeCreateAttach(attachAction) {
  try {
    const st = window.builderState;
    if (!attachAction || attachAction.kind !== "attach") return attachAction;
    const name = attachAction.name;
    const prev = st.undoStack.length ? st.undoStack[st.undoStack.length - 1] : null;
    if (!prev || prev.kind !== "create") return attachAction;
    if (!prev.names || prev.names.length !== 1 || prev.names[0] !== name) return attachAction;

    // Pop the create action and replace with a combined action.
    st.undoStack.pop();
    return {
      kind: "create_attach",
      name,
      // creation payload
      specs: prev.specs || {},
      metas: prev.metas || {},
      // attach delta payload
      prevMeta: attachAction.prevMeta,
      prevPose: attachAction.prevPose,
      nextMeta: attachAction.nextMeta,
      nextPose: attachAction.nextPose
    };
  } catch (e) {
    return attachAction;
  }
}

function __applyUpsert(name, spec) {
  try { window.socket?.emit?.("upstream_update", { [name]: spec }); } catch (e) {}
  try { window.upsertObject?.(name, spec); } catch (e) {}
}

function __applyDelete(name) {
  try { window.socket?.emit?.("upstream_update", { [name]: { delete: true } }); } catch (e) {}
  try { window.upsertObject?.(name, { delete: true }); } catch (e) {}
}


function __undo() {
  const st = window.builderState;

  // Pattern undo priority (robust):
  // If the top undo action would delete the seed (create / create_attach), but a pattern action
  // exists *anywhere below it* that was created using that seed, undo the pattern first.
  // This fixes cases where internal fill helpers accidentally leave a seed-create action above
  // the pattern batch, causing Ctrl+Z to delete the seed instead of undoing the fill.
  let act = st.undoStack.pop();
  if (!act) { showToast("Nothing to undo"); return; }

  try {
    const seedName =
      (act.kind === "create_attach" && act.name) ? act.name :
      (act.kind === "create" && Array.isArray(act.names) && act.names.length === 1) ? act.names[0] :
      null;

    if (seedName) {
      // Find the most recent pattern action in the remaining stack that references this seed.
      let idx = -1;
      for (let i = st.undoStack.length - 1; i >= 0; i--) {
        const a = st.undoStack[i];
        if (!a || a.kind !== "pattern") continue;
        const match = (a.seedName === seedName) ||
                      (Array.isArray(a.seedNames) && a.seedNames.includes(seedName));
        if (match) { idx = i; break; }
      }

      if (idx >= 0) {
        // Put the seed action back on top so it can be undone on the *next* undo,
        // and undo the pattern batch now.
        st.undoStack.push(act);
        act = st.undoStack.splice(idx, 1)[0];
      }
    }
  } catch (e) {}

  st.redoStack.push(act);

  // Helper: restore pose/meta for an existing object
  function __restorePoseMeta(name, meta, pose) {
    if (meta) st.components[name] = __deepClone(meta);
    else delete st.components[name];

    const spec = __deepClone(st.specs[name] || {});
    if (pose) spec.pose = __deepClone(pose);
    if (meta && meta.attach) spec.builder = { attach: __deepClone(meta.attach) };
    else spec.builder = { attach: null };
    __applyUpsert(name, spec);
  }

  // Move (re-attach) should revert, not delete.
  if (act.kind === "attach" && act.op === "move") {
    __restorePoseMeta(act.name, act.prevMeta, act.prevPose);
    clearAnchors(); setSelected(null);
    showToast(`Undid move: ${act.name}`);
    return;
  }

  // Anchoring (attach) should simply delete the anchored object.
  if (act.kind === "attach") {
    const name = act.name;
    delete st.components[name];
    delete st.specs[name];
    __applyDelete(name);
    clearAnchors(); setSelected(null);
    showToast(`Undid anchor (deleted): ${name}`);
    return;
  }

  // A merged create+attach is always undone by deleting the object.
  if (act.kind === "create_attach") {
    const name = act.name;
    delete st.components[name];
    delete st.specs[name];
    __applyDelete(name);
    clearAnchors(); setSelected(null);
    showToast(`Undid joint (deleted): ${name}`);
    return;
  }

  // Transform (move/rotate/flip) should revert pose+meta.
  if (act.kind === "transform") {
    __restorePoseMeta(act.name, act.prevMeta, act.prevPose);
    try { __propagateAnchoredSubtree(act.name); } catch(e) {}
    clearAnchors(); setSelected(null);
    showToast(`Undid transform: ${act.name}`);
    return;
  }

  if (act.kind === "create") {
    for (const n of (act.names || [])) {
      delete st.components[n];
      delete st.specs[n];
      __applyDelete(n);
    }
    clearAnchors(); setSelected(null);
    showToast(`Undid create (${(act.names||[]).length})`);
    return;
  }


if (act.kind === "pattern") {
  // Prefer deleting everything created in this pattern batch (more reliable than name heuristics).
  const toDelete = new Set();
  try {
    if (act.batchId) {
      for (const [n, m] of Object.entries(st.components || {})) {
        if (m && m.__patternBatch === act.batchId) toDelete.add(n);
      }
    }
  } catch (e) {}
  for (const n of (act.names || [])) if (n) toDelete.add(n);

  // Never delete the seed if provided.
  if (act.seedName) toDelete.delete(act.seedName);

  // Delete all created instances.
  const __names = Array.from(toDelete);
  for (const n of __names) {
    delete st.components[n];
    delete st.specs[n];
    __applyDelete(n);
  }
  clearAnchors(); setSelected(null);
  showToast(`Undid pattern (${__names.length})`);
  return;
}


  if (act.kind === "delete") {
    // Undo delete => restore all deleted objects
    for (const n of (act.names || [])) {
      if (act.metas && act.metas[n]) st.components[n] = __deepClone(act.metas[n]);
      const spec = act.specs && act.specs[n] ? __deepClone(act.specs[n]) : null;
      if (spec) {
        st.specs[n] = __deepClone(spec);
        __applyUpsert(n, spec);
      }
    }
    clearAnchors(); setSelected(null);
    showToast(`Undid delete (${(act.names||[]).length})`);
    return;
  }
}

function __redo() {
  const st = window.builderState;
  const act = st.redoStack.pop();
  if (!act) { showToast("Nothing to redo"); return; }
  st.undoStack.push(act);

  function __applyPoseMeta(name, meta, pose) {
    if (meta) st.components[name] = __deepClone(meta);
    const spec = __deepClone(st.specs[name] || {});
    if (pose) spec.pose = __deepClone(pose);
    if (meta && meta.attach) spec.builder = { attach: __deepClone(meta.attach) };
    __applyUpsert(name, spec);
  }

  if (act.kind === "attach" && act.op === "move") {
    __applyPoseMeta(act.name, act.nextMeta, act.nextPose);
    clearAnchors(); setSelected(null);
    showToast(`Redid move: ${act.name}`);
    return;
  }

  if (act.kind === "attach") {
    // Redo anchor: recreate the object and apply the joint if we captured specs/metas
    const name = act.name;
    if (act.spec0) {
      st.specs[name] = __deepClone(act.spec0);
      __applyUpsert(name, __deepClone(act.spec0));
    }
    if (act.nextMeta) st.components[name] = __deepClone(act.nextMeta);
    __applyPoseMeta(name, act.nextMeta, act.nextPose);
    clearAnchors(); setSelected(null);
    showToast(`Redid anchor: ${name}`);
    return;
  }

  if (act.kind === "create_attach") {
    const name = act.name;
    const spec0 = (act.specs && act.specs[name]) ? __deepClone(act.specs[name]) : null;
    const meta0 = (act.metas && act.metas[name]) ? __deepClone(act.metas[name]) : null;
    if (meta0) st.components[name] = meta0;
    if (spec0) {
      st.specs[name] = __deepClone(spec0);
      __applyUpsert(name, spec0);
    }
    // Re-apply attach
    if (act.nextMeta) st.components[name] = __deepClone(act.nextMeta);
    const spec = __deepClone(st.specs[name] || {});
    if (act.nextPose) spec.pose = __deepClone(act.nextPose);
    if (act.nextMeta && act.nextMeta.attach) spec.builder = { attach: __deepClone(act.nextMeta.attach) };
    __applyUpsert(name, spec);
    clearAnchors(); setSelected(null);
    showToast(`Redid joint: ${name}`);
    return;
  }

  if (act.kind === "transform") {
    __applyPoseMeta(act.name, act.nextMeta, act.nextPose);
    try { __propagateAnchoredSubtree(act.name); } catch(e) {}
    clearAnchors(); setSelected(null);
    showToast(`Redid transform: ${act.name}`);
    return;
  }

  if (act.kind === "create") {
    for (const n of (act.names || [])) {
      if (act.metas && act.metas[n]) st.components[n] = __deepClone(act.metas[n]);
      const spec = act.specs && act.specs[n] ? __deepClone(act.specs[n]) : __deepClone(st.specs[n] || {});
      if (spec) {
        st.specs[n] = __deepClone(spec);
        __applyUpsert(n, spec);
      }
    }
    clearAnchors(); setSelected(null);
    showToast(`Redid create (${(act.names||[]).length})`);
    return;
  }


if (act.kind === "pattern") {
  // Recreate all instances recorded for this pattern batch.
  const __names = (act.names || []).filter(n => n && (!act.seedName || n !== act.seedName));
  for (const n of __names) {
    if (act.metas && act.metas[n]) st.components[n] = __deepClone(act.metas[n]);
    const spec = act.specs && act.specs[n] ? __deepClone(act.specs[n]) : null;
    if (spec) {
      st.specs[n] = __deepClone(spec);
      __applyUpsert(n, spec);
    }
  }
  clearAnchors(); setSelected(null);
  showToast(`Redid pattern (${__names.length})`);
  return;
}

  if (act.kind === "delete") {
    // Redo delete => delete them again
    for (const n of (act.names || [])) {
      delete st.components[n];
      delete st.specs[n];
      __applyDelete(n);
    }
    clearAnchors(); setSelected(null);
    showToast(`Redid delete (${(act.names||[]).length})`);
    return;
  }
}

window.__undo = __undo;
window.__redo = __redo;



function showToast(msg) {
  let t = document.getElementById("builderToast");
  if (!t) {
    t = document.createElement("div");
    t.id = "builderToast";
    t.style.position = "fixed";
    t.style.top = "12px";
    t.style.left = "50%";
    t.style.transform = "translateX(-50%)";
    t.style.background = "#111";
    t.style.color = "#fff";
    t.style.padding = "10px 14px";
    t.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";
    t.style.fontSize = "14px";
    t.style.borderRadius = "10px";
    t.style.boxShadow = "0 8px 20px rgba(0,0,0,0.2)";
    t.style.zIndex = "9999";
    t.style.pointerEvents = "none";
    document.body.appendChild(t);
  }
  t.textContent = msg;
  t.style.display = "block";
  clearTimeout(t.__hide);
  t.__hide = setTimeout(() => { t.style.display = "none"; }, 2200);
}

// Expose for any non-module callbacks / inline handlers.
window.showToast = showToast;
function showBanner(text, onCancel) {
  let b = document.getElementById("builderBanner");
  if (!b) {
    b = document.createElement("div");
    b.id = "builderBanner";
    b.style.position = "fixed";
    b.style.left = "50%";
    b.style.bottom = "18px";
    b.style.transform = "translateX(-50%)";
    b.style.background = "rgba(0,0,0,0.75)";
    b.style.color = "#fff";
    b.style.padding = "12px 14px";
    b.style.borderRadius = "12px";
    b.style.border = "1px solid rgba(255,255,255,0.18)";
    b.style.backdropFilter = "blur(6px)";
    b.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";
    b.style.fontSize = "14px";
    b.style.zIndex = "10001";
    b.style.display = "flex";
    b.style.alignItems = "center";
    b.style.gap = "10px";

    const msg = document.createElement("div");
    msg.id = "builderBannerMsg";
    msg.style.whiteSpace = "nowrap";
    b.appendChild(msg);

    const cancel = document.createElement("button");
    cancel.textContent = "Cancel";
    cancel.style.border = "1px solid rgba(255,255,255,0.22)";
    cancel.style.background = "rgba(255,255,255,0.08)";
    cancel.style.color = "#fff";
    cancel.style.padding = "6px 10px";
    cancel.style.borderRadius = "10px";
    cancel.style.cursor = "pointer";
    cancel.onclick = () => { if (onCancel) onCancel(); };
    b.appendChild(cancel);

    document.body.appendChild(b);
  }
  document.getElementById("builderBannerMsg").textContent = text;
  const cancelBtn = b.querySelector("button");
  cancelBtn.onclick = () => { if (onCancel) onCancel(); };
  b.style.display = "flex";
}
function hideBanner() {
  const b = document.getElementById("builderBanner");
  if (b) b.style.display = "none";
}

window.showBanner = showBanner;
window.hideBanner = hideBanner;


function ensureBuilderBar() {
  if (document.getElementById("builderBar")) return;
  const bar = document.createElement("div");
  bar.id = "builderBar";
  bar.style.position = "fixed";
  bar.style.top = "12px";
  bar.style.left = "12px";
  bar.style.display = "flex";
  bar.style.gap = "8px";
  bar.style.zIndex = "9999";

  const mkBtn = (label) => {
    const b = document.createElement("button");
    b.textContent = label;
    b.style.width = "40px";
    b.style.height = "40px";
    b.style.borderRadius = "12px";
    b.style.border = "1px solid rgba(0,0,0,0.12)";
    b.style.background = "#fff";
    b.style.cursor = "pointer";
    b.style.fontSize = "22px";
    b.style.boxShadow = "0 8px 18px rgba(0,0,0,0.10)";
    return b;
  };

  const plus = mkBtn("+");
  plus.title = "Insert";
  plus.addEventListener("click", () => openInsertMenu());

  const save = mkBtn("💾");
  save.title = "Save config.yaml";
  save.addEventListener("click", () => saveConfig());

  const undoB = mkBtn("↶");
  undoB.title = "Undo (Ctrl/Cmd+Z)";
  undoB.addEventListener("click", () => { try { window.__undo?.(); } catch(e) {} });

  const redoB = mkBtn("↷");
  redoB.title = "Redo (Ctrl/Cmd+Y / Ctrl/Cmd+Shift+Z)";
  redoB.addEventListener("click", () => { try { window.__redo?.(); } catch(e) {} });

  bar.appendChild(plus);
  bar.appendChild(save);
  bar.appendChild(undoB);
  bar.appendChild(redoB);
  document.body.appendChild(bar);

  // Action buttons (appear when an object is selected)
  const actions = document.createElement("div");
  actions.id = "builderActions";
  actions.style.position = "fixed";
  actions.style.top = "56px";
  actions.style.left = "12px";
  actions.style.display = "flex";
  actions.style.flexDirection = "column";
  actions.style.gap = "8px";
  actions.style.zIndex = 9999;


  function togglePanMode(){
    window.builderState.panMode = !window.builderState.panMode;
    try {
      if (window.__builderUpdatePanButton) window.__builderUpdatePanButton(window.builderState.panMode);
    } catch(e){}
    try { applyPanMode(); } catch(e){}
  }
  function mkAction(svgMarkup, onClick, titleText="") {
    const b = document.createElement("button");
    b.style.width = "42px";
    b.style.height = "34px";
    b.style.borderRadius = "10px";
    b.style.border = "1px solid rgba(255,255,255,0.25)";
    b.style.background = "rgba(0,0,0,0.55)";
    b.style.color = "#fff";
    b.style.cursor = "pointer";
    b.style.backdropFilter = "blur(4px)";
    b.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";
    b.style.fontSize = "15px";
    b.style.display = "flex";
    b.style.alignItems = "center";
    b.style.justifyContent = "center";
    b.style.padding = "0";
    b.style.boxSizing = "border-box";
    b.style.transition = "transform 0.06s ease, background 0.12s ease, opacity 0.12s ease";
    b.title = titleText;

    const wrap = document.createElement("div");
    wrap.style.width = "24px";
    wrap.style.height = "24px";
    wrap.style.display = "flex";
    wrap.style.alignItems = "center";
    wrap.style.justifyContent = "center";
    wrap.innerHTML = svgMarkup.trim();
    // make inner svg fill the box
    const svg = wrap.querySelector("svg");
    if (svg) {
      svg.setAttribute("width", "24");
      svg.setAttribute("height", "24");
      svg.style.width = "24px";
      svg.style.height = "24px";
      svg.style.display = "block";
    }
    b.appendChild(wrap);

    b.addEventListener("mouseenter", () => { if (!b.disabled) b.style.background = "rgba(0,0,0,0.68)"; });
    b.addEventListener("mouseleave", () => { b.style.background = "rgba(0,0,0,0.55)"; });
    b.addEventListener("mousedown", () => { if (!b.disabled) b.style.transform = "translateY(1px)"; });
    b.addEventListener("mouseup", () => { b.style.transform = "translateY(0)"; });
    b.addEventListener("click", onClick);
    return b;
  }

  const btnRemove = mkAction(`<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M9 3h6m-8 4h10m-9 0v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V7M10 11v8M14 11v8" stroke="white" stroke-width="2" stroke-linecap="round"/>
</svg>`, () => removeSelected(), "Delete");
  const btnRotate = mkAction(`<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M21 12a9 9 0 1 1-3-6.7" stroke="white" stroke-width="2" stroke-linecap="round"/>
  <path d="M21 3v6h-6" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, () => rotateSelected(90), "Rotate 90°");
  const btnMove   = mkAction(`<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 2v20M2 12h20" stroke="white" stroke-width="2" stroke-linecap="round"/>
  <path d="M12 2l-3 3m3-3l3 3M12 22l-3-3m3 3l3-3M2 12l3-3m-3 3l3 3M22 12l-3-3m3 3l-3 3" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, () => moveSelected(), "Move (re-attach)");


  const btnPan    = mkAction(`<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M4 12c0 4 3 8 8 8h2c3 0 6-2 6-5v-2" stroke="white" stroke-width="2" stroke-linecap="round"/>
  <path d="M7 13V6c0-1 1-2 2-2s2 1 2 2v6" stroke="white" stroke-width="2" stroke-linecap="round"/>
  <path d="M11 12V7c0-1 1-2 2-2s2 1 2 2v5" stroke="white" stroke-width="2" stroke-linecap="round"/>
  <path d="M15 12V8c0-1 1-2 2-2s2 1 2 2v6" stroke="white" stroke-width="2" stroke-linecap="round"/>
</svg>`, () => togglePanMode(), "Pan (toggle left-drag)");

  const btnFlip   = mkAction(`<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M6 7h12M6 17h12" stroke="white" stroke-width="2" stroke-linecap="round"/>
  <path d="M12 7v10" stroke="white" stroke-width="2" stroke-linecap="round"/>
  <path d="M9 10l3-3 3 3M9 14l3 3 3-3" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, () => flipSelected(), "Flip (invert Z)");
  // NOTE: Plate autofill pattern removed (was unreliable). Use Rectangular Pattern instead.

  // Fusion-style rectangular pattern (any object): pick second anchor/point, enter counts per axis.
  const btnRectPattern = mkAction(`<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M4 4h7v7H4V4Z" stroke="white" stroke-width="2"/>
  <path d="M13 4h7v7h-7V4Z" stroke="white" stroke-width="2"/>
  <path d="M4 13h7v7H4v-7Z" stroke="white" stroke-width="2"/>
  <path d="M13 13h7v7h-7v-7Z" stroke="white" stroke-width="2"/>
  <path d="M12 2v20" stroke="white" stroke-width="2" stroke-linecap="round" opacity="0.5"/>
  <path d="M2 12h20" stroke="white" stroke-width="2" stroke-linecap="round" opacity="0.5"/>
  </svg>`, () => { try { startRectPattern(); } catch(e){ console.error(e); showToast('RectPattern error: ' + (e.message||e)); } }, "Rectangular Pattern (Fusion-style)");



actions.appendChild(btnRemove);
  actions.appendChild(btnRotate);
  actions.appendChild(btnMove);
  actions.appendChild(btnPan);
  actions.appendChild(btnFlip);
  actions.appendChild(btnRectPattern);
  document.body.appendChild(actions);
  try { applyPanMode(); } catch(e) {}

  window.__builderSetActionsEnabled = (enabled) => {
    // Actions that require a selected object.
    // NOTE: Pan is a mode toggle and should remain available even with no selection.
    for (const b of [btnRemove, btnRotate, btnMove, btnFlip]) {
      b.disabled = !enabled;
      b.style.opacity = enabled ? "1.0" : "0.4";
    }
  }
  // window.__builderSetPatternEnabled removed (plate autofill pattern removed)

  window.__builderSetRectPatternEnabled = (enabled) => {
    if (btnRectPattern) {
      btnRectPattern.disabled = !enabled;
      btnRectPattern.style.opacity = enabled ? "1.0" : "0.4";
    }
  };


}

function openModal(title, buttons) {
  // buttons: [{label, onClick}]
  let bg = document.getElementById("builderModalBg");
  if (bg) bg.remove();
  bg = document.createElement("div");
  bg.id = "builderModalBg";
  bg.style.position = "fixed";
  bg.style.inset = "0";
  bg.style.background = "rgba(0,0,0,0.25)";
  bg.style.zIndex = "10000";
  bg.addEventListener("click", (e) => { if (e.target === bg) bg.remove(); });

  const panel = document.createElement("div");
  panel.style.position = "absolute";
  panel.style.left = "12px";
  panel.style.top = "60px";
  panel.style.maxHeight = "70vh";
  panel.style.overflowY = "auto";
  panel.style.paddingBottom = "10px";
  panel.style.width = "260px";
  panel.style.background = "#fff";
  panel.style.borderRadius = "16px";
  panel.style.border = "1px solid rgba(0,0,0,0.12)";
  panel.style.boxShadow = "0 16px 40px rgba(0,0,0,0.18)";
  panel.style.padding = "12px";
  panel.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";

  const h = document.createElement("div");
  h.textContent = title;
  h.style.fontWeight = "700";
  h.style.marginBottom = "10px";
  panel.appendChild(h);

  for (const btn of buttons) {
    const b = document.createElement("button");
    b.textContent = btn.label;
    b.style.width = "100%";
    b.style.padding = "10px 10px";
    b.style.borderRadius = "12px";
    b.style.border = "1px solid rgba(0,0,0,0.12)";
    b.style.background = "#f7f7f7";
    b.style.cursor = "pointer";
    b.style.marginBottom = "8px";
    b.addEventListener("click", () => {
      try { btn.onClick(); } finally { bg.remove(); }
    });
    panel.appendChild(b);
  }

  bg.appendChild(panel);
  document.body.appendChild(bg);
}

function buildFixturePlateAnchors() {
  const anchors = {};
  const plate_pitch = 25.0;
  const plate_x_start = -237.5;
  const plate_y_start = 112.5;
  const rows = "ABCDEFGHIJ".split("");
  const cols = Array.from({length:20}, (_,i)=>i+1);
  for (let rIdx=0; rIdx<rows.length; rIdx++) {
    const r = rows[rIdx];
    const y = plate_y_start - rIdx * plate_pitch;
    for (const c of cols) {
      const x = plate_x_start + (c-1)*plate_pitch;
      anchors[`${r}${c}`] = [x,y,7,0,0,0];
    }
  }
  anchors["corner_0"] = [-250, 125, 7, 0,0,0];
  anchors["corner_1"] = [ 250, 125, 7, 0,0,0];
  anchors["corner_2"] = [ 250,-125, 7, 0,0,0];
  anchors["corner_3"] = [-250,-125, 7, 0,0,0];
  anchors["center"] = [0,0,7,0,0,0];
  return anchors;
}

function buildSbsAdapterAnchors() {
  return {
    "center": [0,0,0,0,0,0],
    "place":  [0,0,4.5,0,0,0],
    "top":    [0,0,8,0,0,0],
    "front":  [0,0,4.5,0,0,180],
    "back":   [0,0,4.5,0,0,0]
  };
}

async function spawnComponent(type, meta=null, options=null) {
  // Generic spawn for any other component type. Uses /api/type_meta for anchors/options.
  
// Instance naming (collision-safe):
// - Most components use "<type>_<n>"
// - For "core", the first instance is "core" (if free), then "core_2", ...
if (!window.builderState.next[type]) window.builderState.next[type] = 1;

function __nameExists(n) {
  try {
    if (window.builderState.components && window.builderState.components[n]) return true;
    if (typeof objectsByName !== "undefined" && objectsByName && objectsByName[n]) return true;
  } catch (e) {}
  return false;
}

let name;
let i = window.builderState.next[type];

// Propose candidate based on type + index
function __candidate(t, idx) {
  if (t === "core") {
    return (idx === 1) ? "core" : `core_${idx}`;
  }
  return `${t}_${idx}`;
}

name = __candidate(type, i);
while (__nameExists(name)) {
  i += 1;
  name = __candidate(type, i);
}
// Next free index for this type
window.builderState.next[type] = i + 1;


  // Instantiate component server-side (simulation-style) so anchors match exactly.
  let blueprint = null;
  try {
    const res = await fetch("/api/instantiate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ type, options: (options && typeof options === "object") ? options : {} })
    });
    const js = await res.json();
    if (js && js.ok) blueprint = js.blueprint;
  } catch (e) {
    console.warn("instantiate failed", e);
  }

  // Build anchorsBySolid + meshes from blueprint
  let anchorsBySolid = {};
  let meshes = null;
  let glb = (meta && meta.glb) ? meta.glb : `/static/CAD/${type}.glb`;
  if (blueprint && Array.isArray(blueprint.solids) && blueprint.solids.length) {
    meshes = [];
    for (const s of blueprint.solids) {
      if (s && s.solid && s.anchors && Object.keys(s.anchors).length) {
        anchorsBySolid[s.solid] = s.anchors;
      }
      if (s && s.glb) {
        meshes.push({ meshUrl: s.glb, pose: s.pose || [0,0,0,0,0,0], solidName: s.solid });
      }
    }
    // If we got at least one mesh, do multi-mesh rendering.
    if (!meshes.length) meshes = null;
    // For single-mesh fallback, pick the first available GLB
    if (!glb) {
      for (const s of blueprint.solids) {
        if (s && s.glb) { glb = s.glb; break; }
      }
    }
  }

  // pick first solid for anchor UI
  let solidName = "solid_0";
  let anchors = {};
  const solids = Object.keys(anchorsBySolid || {});
  if (solids.length) {
    solidName = solids[0];
    anchors = anchorsBySolid[solidName] || {};
  }

  const spec = {
    meshUrl: meshes ? null : glb,
    meshes: meshes,
    pose: [0,0,((type === "fixture_plate" && !window.builderState.lastFixturePlate) ? 0 : 300),0,0,0],
    visible: true,
    anchors,
    anchorsBySolid,
    type,
    componentName: name,
    solidName
  };

  // include create options (stored for config save)
  const optionsOut = (options && typeof options === "object") ? options : {};
  window.builderState.components[name] = { type, ...optionsOut };

  try { socket.emit("upstream_update", { [name]: spec }); } catch (e) {}
  try { upsertObject(name, spec); } catch (e) {}
  window.builderState.placedOrder.push(name);

  // Undo step #1: creation (so undo after an attach will first un-attach, then delete)
  try {
    __pushUndo({
      kind: "create",
      names: [name],
      specs: { [name]: __deepClone(spec) },
      metas: { [name]: __deepClone(window.builderState.components[name]) }
    });
  } catch (e) {}

  // Special-case: the very first fixture plate has nothing to attach to.
  // Spawn it as the base plate immediately (no anchor selection flow).
  if (type === "fixture_plate" && !window.builderState.lastFixturePlate) {
    window.builderState.lastFixturePlate = name;
    // keep any options (none expected for plates) and no attach yet
    window.builderState.components[name] = Object.assign({}, window.builderState.components[name]||{}, { type: "fixture_plate" });
    showToast(`Spawned ${name}. (Base fixture plate)`);
    return name;
  }

  if (!Object.keys(anchors||{}).length) {
    showToast(`Spawned ${name}. (No anchors present)`);
    return name;
  }

  // Show a menu to choose which anchor on the new object to mount from
  try {
    openChildAnchorMenu(name, anchorsBySolid);
  } catch (e) {
    console.warn(e);
    // fallback: default to first anchor and go to target selection
    const a0 = Object.keys(anchors||{})[0];
    window.builderState.pending = { name, childSolid: solidName, childAnchor: a0 };
    window.builderState.mode = "PICK_TARGET_OBJECT";
    window.builderState.targetName = null;
    showToast("Click a target object, then click its anchor.");
  }
  return name;
}


window.spawnComponent = spawnComponent;

// Spawn without opening the child-anchor picker UI. Used for automated patterning.
// It mirrors spawnComponent() but skips any modal flow.
async function spawnComponentSilent(type, meta=null, options=null) {
  if (!window.builderState.next[type]) window.builderState.next[type] = 1;

  let name;
  if (type === "core") {
    const alreadyHasCore = !!(window.builderState.components && window.builderState.components["core"]);
    if (!alreadyHasCore && window.builderState.next[type] === 1) {
      name = "core";
      window.builderState.next[type] = 2;
    } else {
      name = `core_${window.builderState.next[type]++}`;
    }
  } else {
    name = `${type}_${window.builderState.next[type]++}`;
  }
  // Instantiate server-side so anchors/options match exactly.
  let blueprint = null;
  try {
    const res = await fetch("/api/instantiate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ type, options: (options && typeof options === "object") ? options : {} })
    });
    const js = await res.json();
    if (js && js.ok) blueprint = js.blueprint;
  } catch (e) {
    console.warn("instantiate failed", e);
  }

  let anchorsBySolid = {};
  let meshes = null;
  let glb = (meta && meta.glb) ? meta.glb : `/static/CAD/${type}.glb`;
  if (blueprint && Array.isArray(blueprint.solids) && blueprint.solids.length) {
    meshes = [];
    for (const s of blueprint.solids) {
      if (s && s.solid && s.anchors && Object.keys(s.anchors).length) {
        anchorsBySolid[s.solid] = s.anchors;
      }
      if (s && s.glb) {
        meshes.push({ meshUrl: s.glb, pose: s.pose || [0,0,0,0,0,0], solidName: s.solid });
      }
    }
    if (!meshes.length) meshes = null;
    if (!glb) {
      for (const s of blueprint.solids) {
        if (s && s.glb) { glb = s.glb; break; }
      }
    }
  }

  let solidName = "solid_0";
  let anchors = {};
  const solids = Object.keys(anchorsBySolid || {});
  if (solids.length) {
    solidName = solids[0];
    anchors = anchorsBySolid[solidName] || {};
  }

  const spec = {
    meshUrl: meshes ? null : glb,
    meshes: meshes,
    pose: [0,0,((type === "fixture_plate" && !window.builderState.lastFixturePlate) ? 0 : 300),0,0,0],
    visible: true,
    anchors,
    anchorsBySolid,
    type,
    componentName: name,
    solidName
  };

  const optionsOut = (options && typeof options === "object") ? options : {};
  window.builderState.components[name] = { type, ...optionsOut };

  try { socket.emit("upstream_update", { [name]: spec }); } catch (e) {}
  try { upsertObject(name, spec); } catch (e) {}
  window.builderState.placedOrder.push(name);

  // Undo: creation (silent spawns still behave like normal spawns for Ctrl+Z)
  try {
    __pushUndo({
      kind: "create",
      names: [name],
      specs: { [name]: __deepClone(spec) },
      metas: { [name]: __deepClone(window.builderState.components[name]) }
    });
  } catch (e) {}

// Visual-only QoL: some models (notably fixture_plate) have their origin at mid-height,
// so spawning at z=0 makes them appear to "float" in the builder even though simulation
// may place them differently. If a component is NOT attached, we can auto-drop it so its
// lowest point rests on the ground plane (z=0) in the builder view.
try {
  if (type === "fixture_plate") {
    // Fire-and-forget: wait for GLTF to finish, then drop to ground.
    (async () => {
      const t0 = performance.now();
      while (performance.now() - t0 < 2500) {
        const obj = window.objectsByName && window.objectsByName.get(name);
        // Wait until the object exists and has geometry.
        if (obj && obj.isObject3D && obj.children && obj.children.length) {
          const metaNow = window.builderState.components && window.builderState.components[name];
          if (metaNow && !metaNow.attach) {
            const box = new THREE.Box3().setFromObject(obj);
            const minZ = box.min.z;
            if (isFinite(minZ) && Math.abs(minZ) > 1e-6) {
              obj.position.z -= minZ; // put bottom on z=0
              // Keep server / shared state in sync so it doesn't "snap back".
              const rv = (window.quatToRodriguesDeg) ? window.quatToRodriguesDeg(obj.quaternion) : [0,0,0];
              try { socket.emit("upstream_update", { [name]: { pose: [obj.position.x, obj.position.y, obj.position.z, rv[0], rv[1], rv[2]] } }); } catch(e) {}
            }
          }
          break;
        }
        await new Promise(r => requestAnimationFrame(r));
      }
    })();
  }
} catch (e) {}

return name;
}

window.spawnComponentSilent = spawnComponentSilent;

// =====================
// Anchor/Joints: searchable side-panel picker (pattern-style)
// =====================
function closeAnchorPickPanel() {
  const el = document.getElementById("anchorPickPanel");
  if (el) el.remove();
}

function openAnchorPickPanel(opts) {
  // opts: {
  //   panelId, title, subtitle,
  //   solids: string[], currentSolid?, getCurrentSolid?(), setCurrentSolid?(solid), onSolidChange?(solid)
  //   getAnchorNames(solid)->string[], onPick?(name, solid), onPickAnchor?(name, solid), onCancel?()
  // }
  closeAnchorPickPanel();
  const panel = document.createElement("div");
  panel.id = opts.panelId || "anchorPickPanel";
  panel.style.position = "fixed";
  panel.style.right = "18px";
  panel.style.top = "18px";
  panel.style.width = "360px";
  panel.style.maxHeight = "85vh";
  panel.style.overflow = "hidden";
  panel.style.background = "rgba(255,255,255,0.96)";
  panel.style.border = "1px solid rgba(0,0,0,0.12)";
  panel.style.borderRadius = "16px";
  panel.style.boxShadow = "0 18px 60px rgba(0,0,0,0.18)";
  panel.style.padding = "14px";
  panel.style.zIndex = "10006";
  panel.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
  panel.style.color = "#111";

  const title = document.createElement("div");
  title.textContent = opts.title || "Anchors";
  title.style.fontWeight = "800";
  title.style.fontSize = "16px";
  title.style.marginBottom = "6px";
  panel.appendChild(title);

  if (opts.subtitle) {
    const sub = document.createElement("div");
    sub.textContent = opts.subtitle;
    sub.style.fontSize = "12px";
    sub.style.opacity = "0.75";
    sub.style.marginBottom = "10px";
    panel.appendChild(sub);
  }

  let currentSolid = (opts.getCurrentSolid ? opts.getCurrentSolid() : opts.currentSolid) || (opts.solids && opts.solids.length ? opts.solids[0] : null);

  if (opts.solids && opts.solids.length > 1) {
    const solidRow = document.createElement("div");
    solidRow.style.display = "flex";
    solidRow.style.alignItems = "center";
    solidRow.style.gap = "10px";
    solidRow.style.marginBottom = "10px";

    const solidLabel = document.createElement("div");
    solidLabel.textContent = "Solid";
    solidLabel.style.fontWeight = "700";
    solidLabel.style.width = "60px";
    solidLabel.style.fontSize = "12px";

    const solidSelect = document.createElement("select");
    solidSelect.style.flex = "1";
    solidSelect.style.padding = "8px 10px";
    solidSelect.style.borderRadius = "12px";
    solidSelect.style.border = "1px solid rgba(0,0,0,0.15)";
    solidSelect.style.fontWeight = "700";
    solidSelect.style.fontSize = "12px";
    for (const s of opts.solids) {
      const optEl = document.createElement("option");
      optEl.value = s;
      optEl.textContent = s;
      solidSelect.appendChild(optEl);
    }
    if (currentSolid) solidSelect.value = currentSolid;
    solidSelect.onchange = () => {
      currentSolid = solidSelect.value;
      try { opts.setCurrentSolid && opts.setCurrentSolid(currentSolid); } catch(_) {}
      try { opts.onSolidChange && opts.onSolidChange(currentSolid); } catch(_) {}
      render();
    };

    solidRow.appendChild(solidLabel);
    solidRow.appendChild(solidSelect);
    panel.appendChild(solidRow);
  }

  const search = document.createElement("input");
  search.type = "text";
  search.placeholder = "Search anchors…";
  search.style.width = "100%";
  search.style.boxSizing = "border-box";
  search.style.padding = "10px 10px";
  search.style.borderRadius = "12px";
  search.style.border = "1px solid rgba(0,0,0,0.18)";
  search.style.marginBottom = "10px";
  panel.appendChild(search);

  const list = document.createElement("div");
  list.style.maxHeight = "55vh";
  list.style.overflow = "auto";
  list.style.border = "1px solid rgba(0,0,0,0.10)";
  list.style.borderRadius = "12px";
  list.style.background = "rgba(0,0,0,0.02)";
  panel.appendChild(list);

  function sortAnchors(arr) {
    return (arr || []).slice().sort((a,b)=>a.localeCompare(b, undefined, {numeric:true}));
  }

  function render() {
    list.innerHTML = "";
    const all = sortAnchors((opts.getAnchorNames ? opts.getAnchorNames(currentSolid) : []) || []);
    const q = (search.value || "").trim().toLowerCase();
    const shown = q ? all.filter(n => n.toLowerCase().includes(q)) : all;
    if (!shown.length) {
      const none = document.createElement("div");
      none.textContent = "No matching anchors.";
      none.style.padding = "10px";
      none.style.fontSize = "12px";
      none.style.opacity = "0.7";
      list.appendChild(none);
      return;
    }
    let firstEl = null;
    for (const n of shown) {
      const item = document.createElement("div");
      item.textContent = n;
      item.style.padding = "10px 10px";
      item.style.cursor = "pointer";
      item.style.userSelect = "none";
      item.style.fontSize = "12px";
      item.style.borderBottom = "1px solid rgba(0,0,0,0.06)";
      item.onmouseenter = () => item.style.background = "rgba(90,160,255,0.10)";
      item.onmouseleave = () => item.style.background = "transparent";
      item.onclick = () => {
        try {
          if (opts.onPick) opts.onPick(n, currentSolid);
          else if (opts.onPickAnchor) opts.onPickAnchor(n, currentSolid);
        } catch(e) { console.error(e); }
      };
      if (!firstEl) firstEl = item;
      list.appendChild(item);
    }
    // If user is typing, scroll to first result.
    if (q && firstEl) {
      try { firstEl.scrollIntoView({block:"nearest"}); } catch(_) {}
    }
  }

  search.addEventListener("input", () => render());
  search.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      e.preventDefault();
      try { opts.onCancel && opts.onCancel(); } catch(_) {}
      return;
    }
    if (e.key === "Enter") {
      // pick the first visible item
      const first = list.querySelector("div");
      if (first && first.textContent) {
        try {
          if (opts.onPick) opts.onPick(first.textContent, currentSolid);
          else if (opts.onPickAnchor) opts.onPickAnchor(first.textContent, currentSolid);
        } catch(_) {}
      }
    }
  });

  const bottom = document.createElement("div");
  bottom.style.display = "flex";
  bottom.style.justifyContent = "flex-end";
  bottom.style.gap = "8px";
  bottom.style.marginTop = "10px";

  const cancel = document.createElement("button");
  cancel.textContent = "Cancel";
  cancel.style.padding = "10px 14px";
  cancel.style.borderRadius = "12px";
  cancel.style.border = "1px solid rgba(0,0,0,0.12)";
  cancel.style.background = "#fff";
  cancel.style.fontWeight = "800";
  cancel.style.cursor = "pointer";
  cancel.onclick = () => { try { opts.onCancel && opts.onCancel(); } catch(_) {} };
  bottom.appendChild(cancel);
  panel.appendChild(bottom);

  document.body.appendChild(panel);
  render();
  // focus search after paint
  setTimeout(() => { try { search.focus(); search.select(); } catch(_) {} }, 0);
}


function openChildAnchorMenu(childName, anchorsBySolid) {
  // Side-panel (pattern-style) anchor picker for the spawned object.
  // Searchable list + solid chooser.
  closeAnchorPickPanel();

  function cancelUnanchoredSpawn() {
    try {
      const meta = window.builderState.components?.[childName];
      const isAnchored = !!(meta && meta.attach);
      if (!isAnchored) {
        __deleteComponentByName(childName);
        if (window.builderState.pending && window.builderState.pending.name === childName) window.builderState.pending = null;
        window.builderState.mode = "IDLE";
        try { setSelected(null); } catch(_) {}
        showToast(`Cancelled ${childName}`);
      }
    } catch (e) {
      try { console.warn(e); } catch(_) {}
    }
    closeAnchorPickPanel();
  }

  const solids = Object.keys(anchorsBySolid || {});
  let currentSolid = solids.length ? solids[0] : null;

  openAnchorPickPanel({
    panelId: "anchorPickPanel",
    title: `Anchors on ${childName}`,
    subtitle: "Pick the anchor on the new object you want to mount. Then pick the target object and target anchor.",
    solids,
    getCurrentSolid: () => currentSolid,
    setCurrentSolid: (s) => { currentSolid = s; },
    getAnchorNames: (solidKey) => {
      const a = (solidKey && anchorsBySolid && anchorsBySolid[solidKey]) ? anchorsBySolid[solidKey] : {};
      return Object.keys(a || {});
    },
    onPick: (anchorName) => {
      window.builderState.pending = { name: childName, childSolid: currentSolid, sourceAnchor: anchorName };
      window.builderState.mode = "PICK_TARGET_OBJECT";
      window.builderState.targetName = null;
      // Lock primary selection to the child being jointed.
      try { setSelected(childName); } catch(e) {}
      try { closeAnchorPickPanel(); } catch(e) {}
      showToast("Click a target object (or use the list), then choose its anchor.");
    },
    onCancel: () => cancelUnanchoredSpawn(),
  });
}

function openTargetAnchorMenu(targetName) {
  // Side-panel (pattern-style) anchor picker for the target object.
  const targetObj = objectsByName.get(targetName);
  if (!targetObj) { showToast("Target object missing."); return; }

  const ud = targetObj.userData || {};
  const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;
  const solids = ab ? Object.keys(ab) : [ud.solidName || "solid_0"];
  let currentSolid = (ud.solidName && solids.includes(ud.solidName)) ? ud.solidName : (solids[0] || null);

  openAnchorPickPanel({
    panelId: "anchorPickPanel",
    title: `Anchors on ${targetName}`,
    subtitle: "Search and pick the target anchor (instead of hunting in 3D). You can still click anchors in the scene too.",
    solids,
    getCurrentSolid: () => currentSolid,
    setCurrentSolid: (s) => { currentSolid = s; },
    getAnchorNames: (solidKey) => {
      let anchors = {};
      if (ab && solidKey && ab[solidKey]) anchors = ab[solidKey];
      else if (ud.anchors && typeof ud.anchors === "object") anchors = ud.anchors;
      else if (ab && ab[solids[0]]) anchors = ab[solids[0]];
      return Object.keys(anchors || {});
    },
    onPick: (anchorName) => {
      try {
        // Persist the chosen parent solid for the snap math.
        if (window.builderState && window.builderState.pending) window.builderState.pending.parentSolid = currentSolid;
      } catch(_) {}
      try { handleAnchorPick(targetName, anchorName); } catch(e) { console.error(e); }
    },
    onCancel: () => {
      // If we are mid-joint, cancel should delete pending spawn (user expectation from previous behavior)
      try {
        if (window.builderState?.pending?.name) {
          const nm = window.builderState.pending.name;
          const meta = window.builderState.components?.[nm];
          const isAnchored = !!(meta && meta.attach);
          if (!isAnchored) {
            __deleteComponentByName(nm);
            showToast(`Cancelled ${nm}`);
          }
          window.builderState.pending = null;
          window.builderState.targetName = null;
          window.builderState.mode = "IDLE";
        }
      } catch (e) {}
      try { clearAnchors(); } catch(e) {}
      try { setSelected(null); } catch(e) {}
      closeAnchorPickPanel();
    }
  });
}

function placePlateRelative(name, spec, lastName, dx, dy) {
  // place pose relative by offsetting from last plate pose
  const lastObj = objectsByName.get(lastName);
  let basePose = [0,0,0,0,0,0];
  if (lastObj && lastObj.position) {
    basePose = [lastObj.position.x, lastObj.position.y, lastObj.position.z, 0,0,0];
  }
  spec.pose = [basePose[0] + dx, basePose[1] + dy, basePose[2], 0,0,0];

  if (isOccupiedPlatePose(spec.pose[0], spec.pose[1], spec.pose[2])) {
    showToast("That spot already has a fixture plate.");
    return;
  }

  // record attach (for config generation)
  const attach = {
    parent_name: lastName,
    parent_solid: "fixture_plate",
    parent_anchor: "center",
    child_solid: "fixture_plate",
    child_anchor: "center",
    offset: [dx, dy, 0, 0, 0, 0]
  };
  spec.builder = { attach };

  try { socket.emit("upstream_update", { [name]: spec }); } catch (e) {}
  try { upsertObject(name, spec); } catch (e) {}

  window.builderState.lastFixturePlate = name;
  window.builderState.components[name] = { type: "fixture_plate", attach };
  window.builderState.placedOrder.push(name);
  showToast("Placed fixture plate relative to last.");
}

function isFixturePlateName(n) {
  return typeof n === "string" && n.startsWith("fixture_plate_");
}

function isOccupiedPlatePose(x, y, z=0) {
  const EPS = 1e-6;
  for (const [n, meta] of Object.entries(window.builderState.components)) {
    if (!meta || meta.type !== "fixture_plate") continue;
    const obj = objectsByName.get(n);
    if (!obj) continue;
    if (Math.abs(obj.position.x - x) < EPS &&
        Math.abs(obj.position.y - y) < EPS &&
        Math.abs(obj.position.z - z) < EPS) return true;
  }
  return false;
}

function setSelected(name) {
  window.builderState.selectedName = name;

  // Selection can come from multi-solid meshes. Prefer builderState meta, but fall back to scene userdata.
  const meta = (name && window.builderState.components[name]) ? window.builderState.components[name] : null;
  const sceneObj = name ? objectsByName.get(name) : null;
  const typeName = (meta && meta.type) ? meta.type : (sceneObj?.userData?.typeName || "");
  window.builderState.selectedTypeName = typeName || "";


  const enabled = !!(name && (meta || sceneObj));
  if (window.__builderSetActionsEnabled) window.__builderSetActionsEnabled(enabled);

  try {
    const isPlate = (typeName && typeName.startsWith("plate_"));
    if (window.__builderSetPatternEnabled) window.__builderSetPatternEnabled(!!(enabled && isPlate));
  } catch (e) {}

  // Rectangular pattern: enabled for any selected component (anchored or free).
  try {
    // Rectangular pattern does NOT depend on current selection; it starts a workflow
    // where the user picks the source object/anchor next. Keep it available even
    // when nothing is selected.
    if (window.__builderSetRectPatternEnabled) window.__builderSetRectPatternEnabled(true);
  } catch (e) {}
}


function __collectDescendants(rootName) {
  const out = [];
  const seen = new Set();
  const q = [rootName];
  seen.add(rootName);
  while (q.length) {
    const cur = q.shift();
    // direct children: attach.parent_name === cur
    for (const [n, meta] of Object.entries(window.builderState.components || {})) {
      if (!meta || !meta.attach || !meta.attach.parent_name) continue;
      if (meta.attach.parent_name !== cur) continue;
      if (seen.has(n)) continue;
      seen.add(n);
      out.push(n);
      q.push(n);
    }

    // pattern lineage: patternParent === cur
    for (const [n, meta] of Object.entries(window.builderState.components || {})) {
      if (!meta || !meta.patternParent) continue;
      if (meta.patternParent !== cur) continue;
      if (seen.has(n)) continue;
      seen.add(n);
      out.push(n);
      q.push(n);
    }
  }
  return out;
}


function __deleteComponentByName(name) {
  if (!name) return;

  // Undo: treat delete as an atomic action (can be undone/redone)
  try {
    const st = window.builderState;
    const specSnap = __deepClone(st.specs?.[name] || null);
    const metaSnap = __deepClone(st.components?.[name] || null);
    if (specSnap) {
      __pushUndo({ kind: "delete", names: [name], specs: { [name]: specSnap }, metas: { [name]: metaSnap } });
    }
  } catch(e) {}

  // remove anchors UI if showing for this object
  try { clearAnchors(); } catch(e) {}

  // broadcast deletion (and let upsertObject handle scene disposal)
  try { __applyDelete(name); } catch(e) {}

  // remove from builder state
  try { delete window.builderState.components[name]; } catch(e) {}
  try { delete window.builderState.specs[name]; } catch(e) {}
  try {
    window.builderState.placedOrder = (window.builderState.placedOrder || []).filter(n => n !== name);
    if (window.builderState.lastFixturePlate === name) {
      const rev = [...window.builderState.placedOrder].reverse();
      window.builderState.lastFixturePlate = rev.find(n => window.builderState.components[n]?.type === "fixture_plate") || null;
    }
  } catch(e) {}
}


function removeSelected() {
  const name = window.builderState.selectedName;
  if (!name) return;

  const children = __collectDescendants(name);
  if (!children.length) {
    __deleteComponentByName(name);
    setSelected(null);
    showToast("Removed " + name);
    return;
  }

  // Confirmation modal: delete parent only, or delete parent + children.
  const old = document.getElementById("deleteConfirmMenu");
  if (old) old.remove();

  const overlay = document.createElement("div");
  overlay.id = "deleteConfirmMenu";
  overlay.style.position = "fixed";
  overlay.style.inset = "0";
  overlay.style.background = "rgba(0,0,0,0.45)";
  overlay.style.zIndex = "10006";
  overlay.style.display = "flex";
  overlay.style.alignItems = "center";
  overlay.style.justifyContent = "center";
  overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };

  const card = document.createElement("div");
  card.style.width = "min(560px, 94vw)";
  card.style.maxHeight = "min(86vh, 720px)";
  card.style.overflow = "auto";
  card.style.background = "#fff";
  card.style.borderRadius = "18px";
  card.style.padding = "16px";
  card.style.boxShadow = "0 18px 46px rgba(0,0,0,0.35)";
  card.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";

  const title = document.createElement("div");
  title.textContent = "Delete object?";
  title.style.fontWeight = "900";
  title.style.fontSize = "18px";
  title.style.marginBottom = "6px";

  const msg = document.createElement("div");
  msg.textContent = `"${name}" has ${children.length} child object(s) anchored/patterned to it.`;
  msg.style.fontSize = "13px";
  msg.style.color = "rgba(0,0,0,0.70)";
  msg.style.marginBottom = "12px";

  const row = document.createElement("label");
  row.style.display = "flex";
  row.style.alignItems = "center";
  row.style.gap = "10px";
  row.style.padding = "10px 12px";
  row.style.borderRadius = "14px";
  row.style.border = "1px solid rgba(0,0,0,0.12)";
  row.style.background = "rgba(255,0,0,0.04)";
  row.style.cursor = "pointer";
  row.style.userSelect = "none";

  const cb = document.createElement("input");
  cb.type = "checkbox";
  cb.checked = true;

  const cbText = document.createElement("div");
  cbText.innerHTML = `<div style="font-weight:800;">Delete child objects too</div>
                      <div style="font-size:12px;opacity:.75;">This will delete ${children.length} dependent object(s).</div>`;

  row.appendChild(cb);
  row.appendChild(cbText);

  const list = document.createElement("div");
  list.style.marginTop = "10px";
  list.style.fontSize = "12px";
  list.style.opacity = "0.75";
  list.style.maxHeight = "160px";
  list.style.overflow = "auto";
  list.style.border = "1px solid rgba(0,0,0,0.10)";
  list.style.borderRadius = "12px";
  list.style.padding = "10px";
  list.textContent = children.join(", ");

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.justifyContent = "flex-end";
  actions.style.gap = "10px";
  actions.style.marginTop = "14px";

  const cancel = document.createElement("button");
  cancel.textContent = "Cancel";
  cancel.style.padding = "10px 14px";
  cancel.style.borderRadius = "12px";
  cancel.style.border = "1px solid rgba(0,0,0,0.12)";
  cancel.style.background = "#fff";
  cancel.style.fontWeight = "800";
  cancel.onclick = () => overlay.remove();

  const del = document.createElement("button");
  del.textContent = "Delete";
  del.style.padding = "10px 14px";
  del.style.borderRadius = "12px";
  del.style.border = "1px solid rgba(0,0,0,0.12)";
  del.style.background = "rgba(255,0,0,0.12)";
  del.style.fontWeight = "900";
  del.onclick = () => {
    const deleteChildren = !!cb.checked;

    const namesToDelete = [name].concat(deleteChildren ? children : []);
    const specs = {};
    const metas = {};
    for (const n of namesToDelete) {
      try { specs[n] = __deepClone(window.builderState.specs?.[n] || null); } catch(e) {}
      try { metas[n] = __deepClone(window.builderState.components?.[n] || null); } catch(e) {}
    }

    const __prevSuspend = !!window.builderState.suspendUndo;
    window.builderState.suspendUndo = true;

    if (!deleteChildren) {
      // If keeping children, detach them so they don't reference a deleted parent.
      for (const childName of children) {
        const meta = window.builderState.components[childName];
        if (meta && meta.attach && meta.attach.parent_name === name) {
          delete meta.attach;
          const obj = objectsByName.get(childName);
          if (obj && obj.userData) delete obj.userData.builderAttach;
          try { socket.emit("upstream_update", { [childName]: { builder: { attach: null } } }); } catch(e) {}
        }
      }
    }

    for (const n of (deleteChildren ? children : [])) {
      try { __applyDelete(n); } catch(e) {}
      try { delete window.builderState.components[n]; delete window.builderState.specs[n]; } catch(e) {}
    }
    try { __applyDelete(name); } catch(e) {}
    try { delete window.builderState.components[name]; delete window.builderState.specs[name]; } catch(e) {}

    window.builderState.suspendUndo = __prevSuspend;

    try {
      __pushUndo({ kind: "delete", names: namesToDelete, specs, metas });
    } catch(e) {}

    setSelected(null);
    overlay.remove();
    showToast(deleteChildren ? `Removed ${name} (+${children.length} child)` : `Removed ${name}`);
  };

  actions.appendChild(cancel);
  actions.appendChild(del);

  card.appendChild(title);
  card.appendChild(msg);
  card.appendChild(row);
  card.appendChild(list);
  card.appendChild(actions);

  overlay.appendChild(card);
  document.body.appendChild(overlay);
}

// Allow deleting/cancelling unanchored spawns during the pick flow.
// - Delete/Backspace: delete selected object, or cancel pending spawn if nothing selected
// - Escape: cancel pending spawn (if still unanchored)
document.addEventListener("keydown", (e) => {
  try {
    const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select") return;

    // Undo/Redo (Ctrl/Cmd+Z, Ctrl/Cmd+Y, Ctrl/Cmd+Shift+Z)
    const key = String(e.key || "").toLowerCase();
    const mod = (e.ctrlKey || e.metaKey);
    if (mod && key === "z") {
      if (e.shiftKey) window.__redo?.(); else window.__undo?.();
      e.preventDefault();
      return;
    }
    if (mod && key === "y") {
      window.__redo?.();
      e.preventDefault();
      return;
    }

    const k = e.key;
    const isDel = (k === "Delete" || k === "Backspace");
    const isEsc = (k === "Escape");
    if (!isDel && !isEsc) return;

    const pendingName = window.builderState?.pending?.name || null;
    if (isEsc && pendingName) {
      const meta = window.builderState.components?.[pendingName];
      const isAnchored = !!(meta && meta.attach);
      if (!isAnchored) {
        __deleteComponentByName(pendingName);
        window.builderState.pending = null;
        window.builderState.mode = "IDLE";
        setSelected(null);
        showToast(`Cancelled ${pendingName}`);
      } else {
        window.builderState.pending = null;
        window.builderState.mode = "IDLE";
      }
      e.preventDefault();
      return;
    }

    if (isDel) {
      // If we're mid-attach (spawned a child but haven't finished picking anchors),
      // always allow deleting that pending child even if another object is selected.
      if (pendingName) {
        const meta = window.builderState.components?.[pendingName];
        const isAnchored = !!(meta && meta.attach);
        if (!isAnchored) {
          __deleteComponentByName(pendingName);
          window.builderState.pending = null;
          window.builderState.mode = "IDLE";
          setSelected(null);
          clearAnchors();
          showToast(`Cancelled ${pendingName}`);
          e.preventDefault();
          return;
        }
      }

      if (window.builderState?.selectedName) {
        removeSelected();
        e.preventDefault();
        return;
      }
}
  } catch (err) {
    try { console.warn(err); } catch(_) {}
  }
});


function getPoseABC(meta) {
  // returns [a,b,c] in degrees (roll, pitch, yaw)
  if (!meta) return [0,0,0];
  if (meta.attach && Array.isArray(meta.attach.offset)) {
    const o = meta.attach.offset;
    return [o[3]||0, o[4]||0, o[5]||0];
  }
  if (!Array.isArray(meta.poseABC)) meta.poseABC = [0,0,meta.poseYaw||0];
  return [meta.poseABC[0]||0, meta.poseABC[1]||0, meta.poseABC[2]||0];
}

function setPoseABC(meta, abc) {
  if (!meta) return;
  if (meta.attach) {
    if (!Array.isArray(meta.attach.offset)) meta.attach.offset = [0,0,0,0,0,0];
    meta.attach.offset[3]=abc[0]; meta.attach.offset[4]=abc[1]; meta.attach.offset[5]=abc[2];
  } else {
    meta.poseABC = [abc[0], abc[1], abc[2]];
    meta.poseYaw = abc[2];
  }
}

// Recompute poses for any objects anchored to `rootName` (and recursively those anchored to them).
// This mirrors simulation behavior where rotating/moving a parent updates the entire anchored subtree.
function __propagateAnchoredSubtree(rootName) {
  const comps = window.builderState?.components || {};
  const visited = new Set();

  function walk(parentName) {
    if (!parentName || visited.has(parentName)) return;
    visited.add(parentName);

    for (const [childName, meta] of Object.entries(comps)) {
      const at = meta?.attach;
      if (!at) continue;
      if (at.parent_name !== parentName) continue;

      try {
        __snapChildToParentAnchor(
          childName,
          at.parent_name,
          at.parent_anchor_key || at.parent_anchor,
          at.child_solid,
          at.child_anchor_key || at.child_anchor,
          Array.isArray(at.offset) ? at.offset : [0,0,0,0,0,0],
          at.parent_solid
        );
      } catch (e) {
        console.warn("propagate: resnap failed for", childName, e);
        continue;
      }

      // recurse
      walk(childName);
    }
  }

  walk(rootName);
}


function rotateSelected(deg) {
  const name = window.builderState.selectedName;
  if (!name) return;
  const obj = objectsByName.get(name);
  if (!obj) return;

  const meta = window.builderState.components[name];
  if (!meta) return;

  // Undo: capture state before
  const __prevMeta = __deepClone(meta || null);
  const __prevPose = (function(){
    try {
      const r = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(obj.quaternion) : [0,0,0];
      return [obj.position.x, obj.position.y, obj.position.z, r[0]||0, r[1]||0, r[2]||0];
    } catch (e) { return null; }
  })();

  const __applyUndoSnapshot = () => {
    try {
      const __nextMeta = __deepClone(window.builderState.components[name] || null);
      const r2 = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(obj.quaternion) : [0,0,0];
      const __nextPose = [obj.position.x, obj.position.y, obj.position.z, r2[0]||0, r2[1]||0, r2[2]||0];
      __pushUndo({ kind: "transform", name, prevMeta: __prevMeta, prevPose: __prevPose, nextMeta: __nextMeta, nextPose: __nextPose });
    } catch(e) {}
  };

  // Anchored: update attach offset + resnap
  if (meta.attach) {
    if (!Array.isArray(meta.attach.offset)) meta.attach.offset = [0,0,0,0,0,0];

    // NOTE: attach.offset[3..5] is a Rodrigues rotation vector in degrees (axis * angle),
    // NOT Euler angles. So we must compose rotations with quaternions.
    try {
      const qOff = rodriguesDegToQuaternion(meta.attach.offset[3]||0, meta.attach.offset[4]||0, meta.attach.offset[5]||0);
      const qDelta = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), (deg*Math.PI)/180); // anchor-frame Z
      const qNew = qOff.clone().multiply(qDelta); // post-multiply => rotate in anchor frame
      const rod = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(qNew) : [0,0,0];
      meta.attach.offset[3] = rod[0]||0; meta.attach.offset[4] = rod[1]||0; meta.attach.offset[5] = rod[2]||0;
    } catch (e) {
      // fallback to legacy behavior if something goes wrong
      meta.attach.offset[5] = (meta.attach.offset[5] || 0) + deg;
    }
try {
      __snapChildToParentAnchor(
        name,
        meta.attach.parent_name,
        meta.attach.parent_anchor_key || meta.attach.parent_anchor,
        meta.attach.child_solid,
        meta.attach.child_anchor_key || meta.attach.child_anchor,
        meta.attach.offset,
        meta.attach.parent_solid
      );
    } catch (e) {
      console.warn("rotate: resnap failed", e);
      showToast("Rotate failed (see console)");
      // rollback meta offset on failure
      try { window.builderState.components[name] = __prevMeta; } catch(_) {}
      return;
    }

    try { __propagateAnchoredSubtree(name); } catch (e) {}
    __applyUndoSnapshot();
    showToast("Rotated " + name);
    return;
  }

  // Free: rotate around its own origin
  obj.rotateZ((deg * Math.PI) / 180);
  const abc = getPoseABC(meta);
  abc[2] = (abc[2] || 0) + deg;
  setPoseABC(meta, abc);

  try { __propagateAnchoredSubtree(name); } catch (e) {}

  if (window.socket && socket?.emit) {
    socket.emit("upstream_update", {
      [name]: { pose: [obj.position.x, obj.position.y, obj.position.z, abc[0], abc[1], abc[2]] }
    });
  }

  __applyUndoSnapshot();
  showToast("Rotated " + name);
}



function flipSelected() {
  const name = window.builderState.selectedName;
  if (!name) return;
  const obj = objectsByName.get(name);
  if (!obj) return;

  const meta = window.builderState.components[name];
  if (!meta) return;

  // Undo: capture state before
  const __prevMeta = __deepClone(meta || null);
  const __prevPose = (function(){
    try {
      const r = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(obj.quaternion) : [0,0,0];
      return [obj.position.x, obj.position.y, obj.position.z, r[0]||0, r[1]||0, r[2]||0];
    } catch (e) { return null; }
  })();

  const __applyUndoSnapshot = () => {
    try {
      const __nextMeta = __deepClone(window.builderState.components[name] || null);
      const r2 = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(obj.quaternion) : [0,0,0];
      const __nextPose = [obj.position.x, obj.position.y, obj.position.z, r2[0]||0, r2[1]||0, r2[2]||0];
      __pushUndo({ kind: "transform", name, prevMeta: __prevMeta, prevPose: __prevPose, nextMeta: __nextMeta, nextPose: __nextPose });
    } catch(e) {}
  };

  // Anchored: flip about anchor frame
  if (meta.attach) {
    if (!Array.isArray(meta.attach.offset)) meta.attach.offset = [0,0,0,0,0,0];

    // NOTE: attach.offset[3..5] is a Rodrigues rotation vector in degrees (axis * angle),
    // NOT Euler angles. Compose the flip (180° about anchor-frame X) via quaternions.
    try {
      const qOff = rodriguesDegToQuaternion(meta.attach.offset[3]||0, meta.attach.offset[4]||0, meta.attach.offset[5]||0);
      const qFlip = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), Math.PI); // anchor-frame X
      const qNew = qOff.clone().multiply(qFlip);
      const rod = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(qNew) : [0,0,0];
      meta.attach.offset[3] = rod[0]||0; meta.attach.offset[4] = rod[1]||0; meta.attach.offset[5] = rod[2]||0;
    } catch (e) {
      meta.attach.offset[3] = (meta.attach.offset[3] || 0) + 180;
    }
try {
      __snapChildToParentAnchor(
        name,
        meta.attach.parent_name,
        meta.attach.parent_anchor_key || meta.attach.parent_anchor,
        meta.attach.child_solid,
        meta.attach.child_anchor_key || meta.attach.child_anchor,
        meta.attach.offset,
        meta.attach.parent_solid
      );
    } catch (e) {
      console.warn("flip: resnap failed", e);
      showToast("Flip failed (see console)");
      try { window.builderState.components[name] = __prevMeta; } catch(_) {}
      return;
    }
    try { __propagateAnchoredSubtree(name); } catch (e) {}
    __applyUndoSnapshot();
    showToast("Flipped " + name);
    return;
  }

  // Free: flip about its own origin
  obj.rotateX(Math.PI);

  const abc = getPoseABC(meta);
  abc[0] = (abc[0] || 0) + 180;
  setPoseABC(meta, abc);

  try { __propagateAnchoredSubtree(name); } catch (e) {}

  if (window.socket && socket?.emit) {
    socket.emit("upstream_update", {
      [name]: { pose: [obj.position.x, obj.position.y, obj.position.z, abc[0], abc[1], abc[2]] }
    });
  }

  __applyUndoSnapshot();
  showToast("Flipped " + name);
}



function moveSelected() {
  const name = window.builderState.selectedName;
  if (!name) return;
  const obj = objectsByName.get(name);
  if (!obj) return;

  const anchors = obj.userData?.anchors || {};
  const keys = Object.keys(anchors);
  if (!keys.length) {
    showToast("No anchors available on " + name);
    return;
  }
  keys.sort();

  openModal("Move: choose source anchor", keys.map(k => ({
    label: k,
    onClick: () => {
      const meta = window.builderState.components[name] || {};
      const type = meta.type || obj.userData?.type || "unknown";
      const childSolid =
        (type === "fixture_plate") ? "fixture_plate" :
        (type === "tool_rack") ? "tool_rack" :
        (type === "core") ? "rail_base" :
        "solid_0";

      window.builderState.pending = { name, type, sourceAnchor: k, childSolid, op: "move" };
      window.builderState.mode = "PICK_TARGET_OBJECT";
      window.builderState.targetName = null;
      showToast("Click the target object, then click its anchor.");
    }
  })));
}



function openInsertMenu() {
  // Icon tile menu (Fusion-ish)
  let bg = document.getElementById("builderModalBg");
  if (bg) bg.remove();
  bg = document.createElement("div");
  bg.id = "builderModalBg";
  bg.style.position = "fixed";
  bg.style.inset = "0";
  bg.style.background = "rgba(0,0,0,0.25)";
  bg.style.zIndex = "9998";
  bg.addEventListener("click", (e) => { if (e.target === bg) bg.remove(); });

  const box = document.createElement("div");
  box.style.position = "absolute";
  box.style.left = "12px";
  box.style.top = "60px";
  box.style.width = "460px";
  box.style.maxWidth = "calc(100vw - 24px)";
  box.style.maxHeight = "80vh";
  box.style.display = "flex";
  box.style.flexDirection = "column";
  box.style.background = "#fff";
  box.style.borderRadius = "16px";
  box.style.border = "1px solid rgba(0,0,0,0.12)";
  box.style.boxShadow = "0 16px 40px rgba(0,0,0,0.18)";
  box.style.padding = "12px";
  box.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";
  box.style.userSelect = "none";

  const header = document.createElement("div");
  header.textContent = "Insert";
  header.style.fontWeight = "800";
  header.style.marginBottom = "10px";
  box.appendChild(header);

  const grid = document.createElement("div");
  grid.style.display = "grid";
  grid.style.gridTemplateColumns = "repeat(3, minmax(0, 1fr))";
  grid.style.gap = "10px";
  grid.style.overflowY = "auto";
  grid.style.overflowX = "hidden";
  grid.style.paddingRight = "4px";
  grid.style.flex = "1";
  box.appendChild(grid);

  const mkTile = ({name, iconSvg, onClick}) => {
    const t = document.createElement("button");
    t.style.display = "flex";
    t.style.minWidth = "0";
    t.style.flexDirection = "column";
    t.style.alignItems = "center";
    t.style.justifyContent = "center";
    t.style.gap = "6px";
    t.style.padding = "10px 8px";
    t.style.borderRadius = "14px";
    t.style.border = "1px solid rgba(0,0,0,0.10)";
    t.style.background = "#f8fbff";
    t.style.cursor = "pointer";
    t.style.boxShadow = "0 4px 10px rgba(0,0,0,0.06)";
    t.addEventListener("click", () => { bg.remove(); onClick(); });

    const icon = document.createElement("div");
    icon.innerHTML = iconSvg;
    icon.style.width = "40px";
    icon.style.height = "40px";
    icon.style.display = "grid";
    icon.style.placeItems = "center";

    const lbl = document.createElement("div");
    lbl.textContent = name;
    lbl.style.fontSize = "11px";
    lbl.style.opacity = "0.85";
    lbl.style.lineHeight = "1.1";
    lbl.style.textAlign = "center";

    t.appendChild(icon);
    t.appendChild(lbl);
    return t;
  };

  
  // Thumbnails: render actual GLB model into a small offscreen canvas and cache in localStorage.
// Goal: Fusion-like catalog thumbnails: object centered, consistently framed (no random zoom/crop),
// with an isometric-ish view that works across flat plates and tall parts.
const THUMB_SIZE = 512;
// Bump to force regeneration (avoids stale localStorage thumbs when logic changes)
const THUMB_VERSION = "fusion_v5";

async function getOrCreateThumbnail(modelKey, glbUrl) {
  const key = "builder_thumb_" + THUMB_VERSION + "_" + modelKey;
  try {
    const cached = localStorage.getItem(key);
    if (cached && cached.startsWith("data:image/")) return cached;
  } catch (e) {}

  const canvas = document.createElement("canvas");
  const r = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, preserveDrawingBuffer: true });
  try { r.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2)); } catch (e) {}
  r.setSize(THUMB_SIZE, THUMB_SIZE, false);
  r.outputColorSpace = THREE.SRGBColorSpace;

  const scn = new THREE.Scene();

  // Perspective camera + deterministic "fit to frame" gives more natural thumbnails than ortho.
  // We'll keep a consistent diagonal view (top-right-ish) and then dolly the camera so the
  // projected bounds fill the thumbnail with a small margin.
  const cam = new THREE.PerspectiveCamera(35, 1, 0.01, 5000);

  // Lights: neutral product-shot
  scn.add(new THREE.AmbientLight(0xffffff, 0.72));
  const keyL = new THREE.DirectionalLight(0xffffff, 0.85);
  keyL.position.set(2.5, 3.0, 4.0);
  scn.add(keyL);
  const fillL = new THREE.DirectionalLight(0xffffff, 0.35);
  fillL.position.set(-3.0, -1.0, 2.0);
  scn.add(fillL);

  const gltf = await new Promise((resolve, reject) => {
    const loader = new GLTFLoader();
    loader.load(glbUrl, resolve, undefined, reject);
  });

  const obj = gltf.scene;
  scn.add(obj);

  // --- Robust bounds helpers (ignore common helper/collision shells) ---
  
  function computeRobustBounds(root) {
    // Build per-mesh world-space boxes, then reject extreme outliers by size AND by distance from the "main cluster".
    const boxes = [];
    root.updateMatrixWorld(true);

    root.traverse((n) => {
      if (!n || !n.isMesh || !n.geometry) return;
      if (n.visible === false) return;

      const nm = (n.name || "").toLowerCase();
      if (nm.includes("collider") || nm.includes("collision") || nm.includes("helper") || nm.includes("bounds")) return;

      const g = n.geometry;
      if (!g.boundingBox) g.computeBoundingBox();
      if (!g.boundingBox) return;

      const bb = g.boundingBox.clone();
      bb.applyMatrix4(n.matrixWorld);

      const sz = new THREE.Vector3();
      bb.getSize(sz);
      const diag = sz.length();
      if (!isFinite(diag) || diag < 1e-9) return;

      const ctr = new THREE.Vector3();
      bb.getCenter(ctr);
      boxes.push({ bb, diag, ctr });
    });

    if (!boxes.length) {
      return new THREE.Box3().setFromObject(root);
    }

    // 1) filter by diagonal outliers
    const diags = boxes.map(x => x.diag).sort((a,b) => a-b);
    const medDiag = diags[Math.floor(diags.length / 2)] || diags[0] || 1;
    const maxKeepDiag = medDiag * 6;

    let kept = boxes.filter(x => x.diag <= maxKeepDiag);
    if (!kept.length) kept = boxes.slice();

    // 2) filter by center-distance outliers (stray far-away helper meshes)
    const xs = kept.map(v=>v.ctr.x).sort((a,b)=>a-b);
    const ys = kept.map(v=>v.ctr.y).sort((a,b)=>a-b);
    const zs = kept.map(v=>v.ctr.z).sort((a,b)=>a-b);
    const mx = xs[Math.floor(xs.length/2)] || 0;
    const my = ys[Math.floor(ys.length/2)] || 0;
    const mz = zs[Math.floor(zs.length/2)] || 0;
    const medianCenter = new THREE.Vector3(mx,my,mz);

    const dists = kept.map(x => x.ctr.distanceTo(medianCenter)).sort((a,b)=>a-b);
    const medDist = dists[Math.floor(dists.length/2)] || 0;
    const maxKeepDist = Math.max(medDist * 6, medDiag * 2);

    const kept2 = kept.filter(x => x.ctr.distanceTo(medianCenter) <= maxKeepDist);
    const use = kept2.length ? kept2 : kept;

    const out = new THREE.Box3();
    out.makeEmpty();
    for (const x of use) out.union(x.bb);
    return out;
  }

  function boxCorners(box) {
    const mn = box.min, mx = box.max;
    return [
      new THREE.Vector3(mn.x, mn.y, mn.z),
      new THREE.Vector3(mn.x, mn.y, mx.z),
      new THREE.Vector3(mn.x, mx.y, mn.z),
      new THREE.Vector3(mn.x, mx.y, mx.z),
      new THREE.Vector3(mx.x, mn.y, mn.z),
      new THREE.Vector3(mx.x, mn.y, mx.z),
      new THREE.Vector3(mx.x, mx.y, mn.z),
      new THREE.Vector3(mx.x, mx.y, mx.z),
    ];
  }

  function centerObjectAtOrigin(root) {
    // Compute bounds, shift to origin, then recompute bounds after shift.
    const b = computeRobustBounds(root);
    const c = new THREE.Vector3();
    b.getCenter(c);
    root.position.sub(c);
    root.updateMatrixWorld(true);
    return computeRobustBounds(root);
  }

  // 1) center in world
  let b0 = centerObjectAtOrigin(obj);
  const sz0 = new THREE.Vector3();
  b0.getSize(sz0);
  const maxDim0 = Math.max(sz0.x, sz0.y, sz0.z) || 1;
  const minDim0 = Math.min(sz0.x, sz0.y, sz0.z) || 1;
  const isFlat = (minDim0 / maxDim0) < 0.20;

  // 2) Fusion-like orientation: choose a good "product shot" angle automatically
  //    - flat parts: stronger tilt so you can see the face
  //    - long parts: rotate so the long axis is visible (not end-on)
  //    - tall parts: slightly less top-down so height reads better
  let yaw = Math.PI / 4;      // default 45°
  let pitch = -0.62;          // default tilt
  let roll = 0.12;            // slight roll for depth

  // dominant axis in the *unrotated* bounds
  const dims = [sz0.x, sz0.y, sz0.z];
  const maxI = dims.indexOf(Math.max(...dims));
  const sorted = [...dims].sort((a,b)=>b-a);
  const maxD = sorted[0] || 1;
  const midD = sorted[1] || 1;

  if (isFlat) {
    pitch = -0.95;
    roll = 0.0;
    yaw = Math.PI / 4;
  } else {
    // If one axis is clearly dominant, rotate so it's shown diagonally
    const isVeryLong = (maxD / Math.max(midD, 1e-6)) > 1.45;
    if (isVeryLong) {
      // x-dominant → keep 45°; z-dominant → rotate 90°
      if (maxI === 2) yaw = 3 * Math.PI / 4;     // 135°
      else yaw = Math.PI / 4;                    // 45°
    }

    // y-dominant (tall) → less top-down
    if (maxI === 1) pitch = -0.48;
    // very squat (nearly flat but not quite) → slightly stronger tilt
    if ((minDim0 / maxDim0) < 0.33) pitch = -0.72;
  }

  obj.rotation.set(pitch, yaw, roll);
  obj.updateMatrixWorld(true);

  // 3) re-center again after rotation
  const b1 = centerObjectAtOrigin(obj);

  // 4) Place camera on a consistent diagonal (top-right-ish) and dolly to fit.
  //    This avoids the "random zoom" feel by making framing depend only on the model bounds.
  const dir = (isFlat
    ? new THREE.Vector3(1.0, 1.25, 1.0)   // slightly more top-down for plates
    : new THREE.Vector3(1.0, 0.85, 1.15)  // general 3/4 view
  ).normalize();

  const sphere = new THREE.Sphere();
  b1.getBoundingSphere(sphere);
  const radius = Math.max(sphere.radius, 1e-3);

  // Start at the theoretical distance to fit the bounding sphere vertically, then pad.
  const fovRad = THREE.MathUtils.degToRad(cam.fov);
  let dist = (radius / Math.sin(fovRad / 2)) * 1.18;

  // Fit in NDC by moving the camera along dir (perspective "zoom").
  const corners = boxCorners(b1);
  const safety = 0.90; // guaranteed full visibility margin
  const target = 0.82; // desired fill (bigger = tighter)

  for (let i = 0; i < 7; i++) {
    cam.position.copy(dir).multiplyScalar(dist);
    cam.lookAt(0, 0, 0);
    cam.updateMatrixWorld(true);
    cam.updateProjectionMatrix();

    let maxAbsX = 0, maxAbsY = 0;
    for (const p of corners) {
      const q = p.clone().project(cam); // NDC [-1, 1]
      maxAbsX = Math.max(maxAbsX, Math.abs(q.x));
      maxAbsY = Math.max(maxAbsY, Math.abs(q.y));
    }
    const maxAbs = Math.max(maxAbsX, maxAbsY, 1e-6);

    let desired;
    if (maxAbs > safety) desired = safety;      // too big => pull back
    else if (maxAbs < target) desired = target; // too small => move in
    else break;

    // In perspective, projected size is ~1/dist, so dist scales by (maxAbs/desired).
    const scale = maxAbs / desired;
    dist = Math.max(0.01, Math.min(50000, dist * scale));
    if (Math.abs(scale - 1) < 0.004) break;
  }

  cam.near = Math.max(0.001, dist - radius * 4.0);
  cam.far  = dist + radius * 8.0;
  cam.updateProjectionMatrix();

  // Render (transparent)
  try { r.setClearColor(0x000000, 0); } catch (e) {}
  r.render(scn, cam);

  const dataUrl = canvas.toDataURL("image/png");
  try { localStorage.setItem(key, dataUrl); } catch (e) {}
  r.dispose();
  return dataUrl;
}

  function mkThumbIcon(modelKey, glbUrl) {
    const wrap = document.createElement("div");
    wrap.style.width = "96px";
    wrap.style.height = "96px";
    wrap.style.borderRadius = "12px";
    wrap.style.background = "#10151c";
    wrap.style.display = "flex";
    wrap.style.alignItems = "center";
    wrap.style.justifyContent = "center";
    wrap.style.overflow = "hidden";

    const img = document.createElement("img");
    img.alt = modelKey;
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "contain";
    img.style.imageRendering = "auto";
    wrap.appendChild(img);

    // placeholder while generating
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="44" height="44">
        <rect x="0" y="0" width="44" height="44" rx="12" fill="rgba(0,0,0,0.04)"/>
        <path d="M22 10a12 12 0 1 0 0.01 0" fill="none" stroke="rgba(0,0,0,0.25)" stroke-width="3" stroke-linecap="round"/>
      </svg>`);

    getOrCreateThumbnail(modelKey, glbUrl).then((url) => { img.src = url; }).catch(() => {});
    return wrap;
  }

  // Populate catalog automatically from /api/catalog (scans static/CAD/*.glb)
  (async () => {
    let items = ["fixture_plate", "sbs_adapter"]; // fallback
    try {
      const res = await fetch("/api/catalog", { cache: "no-store" });
      const js = await res.json();
      if (js && js.ok && Array.isArray(js.items) && js.items.length) items = js.items;
    } catch (e) {}

    // Prefer fixture_plate near top
    items = items.slice().sort((a,b) => {
      if (a === "fixture_plate") return -1;
      if (b === "fixture_plate") return 1;
      return a.localeCompare(b);
    });

    for (const type of items) {
      const glb = "/static/CAD/" + type + ".glb";
      const tile = mkTile({ name: type, iconSvg: "", onClick: () => openCreatePanel(type) });
      grid.appendChild(tile);
      tile.querySelector("div").replaceWith(mkThumbIcon(type, glb));
    }
  })();
bg.appendChild(box);
  document.body.appendChild(bg);
}

// Simple "Create" panel.
// (We can auto-detect options later; for now, this guarantees spawning works again.)
async function openCreatePanel(typeName) {
  const old = document.getElementById("createPanel");
  if (old) old.remove();

  // fetch metadata (anchors + options + glb guess)
  let meta = { type: typeName, options: [], anchors: {}, glb: null };
  try {
    const res = await fetch("/api/type_meta?type=" + encodeURIComponent(typeName), { cache: "no-store" });
    const js = await res.json();
    if (js && js.ok && js.meta) meta = js.meta;
  } catch (e) {}

  const panel = document.createElement("div");
  panel.id = "createPanel";
  panel.style.position = "fixed";
  panel.style.inset = "0";
  panel.style.background = "rgba(10,10,10,0.65)";
  panel.style.zIndex = "10002";
  panel.addEventListener("click", (e) => { if (e.target === panel) panel.remove(); });

  const card = document.createElement("div");
  card.style.position = "absolute";
  card.style.left = "50%";
  card.style.top = "50%";
  card.style.transform = "translate(-50%,-50%)";
  card.style.width = "min(780px, 92vw)";
  card.style.maxHeight = "min(86vh, 820px)";
  card.style.overflow = "auto";
  card.style.background = "#fff";
  card.style.borderRadius = "18px";
  card.style.padding = "16px";
  card.style.boxShadow = "0 18px 46px rgba(0,0,0,0.35)";
  card.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";

  const title = document.createElement("div");
  title.textContent = "Create: " + typeName;
  title.style.fontWeight = "800";
  title.style.fontSize = "18px";
  title.style.marginBottom = "6px";

  const hint = document.createElement("div");
  hint.textContent = "Set options (if any), then click Create.";
  hint.style.opacity = "0.7";
  hint.style.fontSize = "13px";
  hint.style.marginBottom = "14px";

  // options form (auto)
  const form = document.createElement("div");
  form.style.display = "grid";
  form.style.gridTemplateColumns = "1fr 1fr";
  form.style.gap = "10px 14px";
  form.style.marginBottom = "14px";

  const fields = {};
  const optsAll = Array.isArray(meta.options) ? meta.options : [];
  // Do not surface the internal `simulation` toggle in the Builder UI.
  const opts = optsAll.filter(o => o && o.kind === "bool" && String(o.name || o.key || "") !== "simulation");
  if (!opts.length) {
    const none = document.createElement("div");
    none.textContent = "";
    none.style.gridColumn = "1 / -1";
    none.style.opacity = "0.7";
    none.style.fontSize = "13px";
    form.appendChild(none);
  } else {
    for (const opt of opts) {
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.alignItems = "center";
      wrap.style.justifyContent = "space-between";
      wrap.style.gap = "10px";
      wrap.style.border = "1px solid rgba(0,0,0,0.08)";
      wrap.style.borderRadius = "12px";
      wrap.style.padding = "10px 12px";
      wrap.style.background = "#fafafa";

      const lab = document.createElement("div");
      lab.textContent = opt.name;
      lab.style.fontSize = "13px";
      lab.style.fontWeight = "650";
      lab.style.opacity = "0.9";

      let input;
      if (opt.kind === "bool") {
        input = document.createElement("input");
        input.type = "checkbox";
        input.checked = !!opt.default;
        input.style.transform = "scale(1.25)";
      } else {
        input = document.createElement("input");
        input.type = "text";
        input.value = (opt.default === undefined || opt.default === null) ? "" : (typeof opt.default === "object" ? JSON.stringify(opt.default) : String(opt.default));
        input.style.flex = "1";
        input.style.padding = "8px 10px";
        input.style.borderRadius = "10px";
        input.style.border = "1px solid rgba(0,0,0,0.12)";
        input.style.background = "#fff";
      }
      fields[opt.name] = { opt, input };
      wrap.appendChild(lab);
      wrap.appendChild(input);
      form.appendChild(wrap);
    }
  }

  // preview (async, don't block UI)
  const prev = document.createElement("div");
  prev.style.border = "1px solid rgba(0,0,0,0.08)";
  prev.style.borderRadius = "14px";
  prev.style.padding = "10px";
  prev.style.background = "#fafafa";
  prev.style.marginBottom = "12px";
  const prevTitle = document.createElement("div");
  prevTitle.textContent = "Preview";
  prevTitle.style.fontSize = "13px";
  prevTitle.style.fontWeight = "700";
  prevTitle.style.marginBottom = "8px";
  const img = document.createElement("img");
  img.style.width = "100%";
  img.style.height = "260px";
  img.style.objectFit = "contain";
  img.style.borderRadius = "12px";
  img.style.background = "rgba(0,0,0,0.06)";
  img.alt = typeName;
  prev.appendChild(prevTitle);
  prev.appendChild(img);

  // load thumbnail after paint
  setTimeout(async () => {
    try {
      const glb = meta.glb || ("/static/CAD/" + typeName + ".glb");
      img.src = await getOrCreateThumbnail(typeName, glb);
    } catch (e) {
      // ignore
    }
  }, 0);

  const row = document.createElement("div");
  row.style.display = "flex";
  row.style.gap = "10px";
  row.style.justifyContent = "flex-end";

  const cancel = document.createElement("button");
  cancel.textContent = "Cancel";
  cancel.style.padding = "10px 14px";
  cancel.style.borderRadius = "12px";
  cancel.style.border = "1px solid rgba(0,0,0,0.12)";
  cancel.style.background = "#f6f6f6";
  cancel.onclick = () => panel.remove();

  const create = document.createElement("button");
  create.textContent = "Create";
  create.style.padding = "10px 14px";
  create.style.borderRadius = "12px";
  create.style.border = "1px solid rgba(0,0,0,0.12)";
  create.style.background = "rgba(90,160,255,0.25)";
  create.style.fontWeight = "800";
  create.onclick = async () => {
    // collect values
    const optsOut = {};
    for (const k in fields) {
      const { opt, input } = fields[k];
      // Only boolean/toggle options are exposed in Builder
      if (opt && opt.kind === "bool") optsOut[k] = !!input.checked;
    }
    panel.remove();
    try { await spawnComponent(typeName, meta, optsOut); }
    catch (e) { console.error(e); showToast("Create failed: " + (e?.message||e)); }
  };

  row.appendChild(cancel);
  row.appendChild(create);

  card.appendChild(title);
  card.appendChild(hint);
  card.appendChild(prev);
  card.appendChild(form);
  card.appendChild(row);
  panel.appendChild(card);
  document.body.appendChild(panel);
}

	// Pick a valid solid key for a multi-solid component.
	// IMPORTANT: Never default to "solid_0" unless it actually exists; otherwise
	// configs can reference missing solids and crash Workspace() with KeyError.
	function __resolveSolidKey(obj, preferredSolid=null) {
	  const ud = obj?.userData || {};
	  const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;
	  const keys = ab ? Object.keys(ab) : [];
	  if (!keys.length) return (ud && ud.solidName) ? ud.solidName : null;

	  function pickFromWant(want) {
	    if (!want) return null;
	    if (ab[want]) return want;
	    const w = String(want).toLowerCase();
	    const exactCI = keys.find(k => String(k).toLowerCase() === w);
	    if (exactCI) return exactCI;
	    const contains = keys.find(k => String(k).toLowerCase().includes(w) || w.includes(String(k).toLowerCase()));
	    if (contains) return contains;
	    return null;
	  }

	  return (
	    pickFromWant(preferredSolid) ||
	    pickFromWant(ud.solidName) ||
	    (keys.includes("solid_0") ? "solid_0" : keys[0])
	  );
	}

	function handleAnchorPick(ownerName, anchorName, pickedSolidKey=null) {
  // Only meaningful during builder snapping
  if (window.builderState.mode !== "PICK_TARGET_ANCHOR" || !window.builderState.pending) return;
  if (!window.builderState.targetName || ownerName !== window.builderState.targetName) return;

  const childName = window.builderState.pending.name;
  const childObj = objectsByName.get(childName);
  const targetObj = objectsByName.get(ownerName);
  if (!childObj || !targetObj) return;

  // Undo support: capture state before we change anything
  const __prevMeta = __deepClone(window.builderState.components[childName] || null);
  const __prevPose = (function(){
    try {
      const r = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(childObj.quaternion) : [0,0,0];
      return [childObj.position.x, childObj.position.y, childObj.position.z, r[0]||0, r[1]||0, r[2]||0];
    } catch (e) { return null; }
  })();

  // Some objects (notably plates) store anchors under anchorsBySolid instead of anchors.
  // IMPORTANT: honor the user-selected solid (e.g. tool changer) when snapping.
	  // Pick a valid solid key for a multi-solid component.
	  // IMPORTANT: Never default to "solid_0" unless it actually exists; otherwise
	  // configs can reference missing solids and crash Workspace() with KeyError.
	  function __resolveSolidKey(obj, preferredSolid=null) {
	    const ud = obj?.userData || {};
	    const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;
	    const keys = ab ? Object.keys(ab) : [];
	    if (!keys.length) return (ud && ud.solidName) ? ud.solidName : null;
	
	    function pickFromWant(want) {
	      if (!want) return null;
	      if (ab[want]) return want;
	      const w = String(want).toLowerCase();
	      const exactCI = keys.find(k => String(k).toLowerCase() === w);
	      if (exactCI) return exactCI;
	      const contains = keys.find(k => String(k).toLowerCase().includes(w) || w.includes(String(k).toLowerCase()));
	      if (contains) return contains;
	      return null;
	    }
	
	    return (
	      pickFromWant(preferredSolid) ||
	      pickFromWant(ud.solidName) ||
	      (keys.includes("solid_0") ? "solid_0" : keys[0])
	    );
	  }

	  function __getAnchorsForObj(obj, preferredSolid=null) {
    const ud = obj?.userData || {};
    const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;
    // If UI selected a solid, use that solid's anchors even if ud.anchors exists.
    if (preferredSolid && ab) {
      if (ab[preferredSolid]) return ab[preferredSolid];
      const want = String(preferredSolid).toLowerCase();
      const keys = Object.keys(ab);
      const exactCI = keys.find(k => String(k).toLowerCase() === want);
      if (exactCI && ab[exactCI]) return ab[exactCI];
      const contains = keys.find(k => String(k).toLowerCase().includes(want) || want.includes(String(k).toLowerCase()));
      if (contains && ab[contains]) return ab[contains];
    }
    if (ud.anchors && typeof ud.anchors === "object" && Object.keys(ud.anchors).length) return ud.anchors;
    if (!ab) return {};
    const solid = (ud.solidName && ab[ud.solidName]) ? ud.solidName : (ab["solid_0"] ? "solid_0" : Object.keys(ab)[0]);
    return (solid && ab[solid]) ? ab[solid] : {};
  }


  const childAnchors = __getAnchorsForObj(childObj, window.builderState.pending.childSolid);
  // If the user clicked a specific anchor that belongs to a particular solid within a
  // multi-solid assembly, honor that for the snap math.
  const __prefParentSolid = pickedSolidKey || window.builderState.pending.parentSolid || null;
  if (pickedSolidKey && window.builderState && window.builderState.pending) {
    try { window.builderState.pending.parentSolid = pickedSolidKey; } catch(_) {}
  }
  const targetAnchors = __getAnchorsForObj(targetObj, __prefParentSolid);
  const srcArr = childAnchors[window.builderState.pending.sourceAnchor];
  const dstArr = targetAnchors[anchorName];
  if (!srcArr || !dstArr) return;

  const srcPL = new THREE.Vector3(srcArr[0], srcArr[1], srcArr[2]);
  const srcQL = rodriguesDegToQuaternion(srcArr[3], srcArr[4], srcArr[5]);

  // If the chosen anchor belongs to a specific solid within a multi-solid assembly,
  // convert from that solid's local frame into the component root's local frame.
  function __solidAnchorToRoot(obj, solidKey, pLocal, qLocal) {
    try {
      if (!solidKey) return { p: pLocal, q: qLocal };
      const holder = obj.getObjectByName ? obj.getObjectByName(String(solidKey)) : null;
      if (!holder || holder === obj) return { p: pLocal, q: qLocal };
      // Position: holderLocal -> world -> objLocal
      const pW = holder.localToWorld(pLocal.clone());
      const pRoot = obj.worldToLocal(pW.clone());
      // Orientation: holderLocal -> world -> objLocal
      const hW = new THREE.Quaternion();
      const oW = new THREE.Quaternion();
      holder.getWorldQuaternion(hW);
      obj.getWorldQuaternion(oW);
      const qW = hW.clone().multiply(qLocal);
      const qRoot = oW.clone().invert().multiply(qW);
      return { p: pRoot, q: qRoot };
    } catch (e) {
      return { p: pLocal, q: qLocal };
    }
  }
  const __srcX = __solidAnchorToRoot(childObj, window.builderState.pending.childSolid, srcPL, srcQL);
  const srcPL_root = __srcX.p;
  const srcQL_root = __srcX.q;

  const dstPL = new THREE.Vector3(dstArr[0], dstArr[1], dstArr[2]);
  const dstQL = rodriguesDegToQuaternion(dstArr[3], dstArr[4], dstArr[5]);

  const __dstX = __solidAnchorToRoot(targetObj, __prefParentSolid || targetObj.userData?.solidName, dstPL, dstQL);
  const dstPL_root = __dstX.p;
  const dstQL_root = __dstX.q;

  const dstWorldPos = targetObj.localToWorld(dstPL_root.clone());
  const targetWorldQ = new THREE.Quaternion();
  targetObj.getWorldQuaternion(targetWorldQ);
  const dstWorldQ = targetWorldQ.clone().multiply(dstQL_root);

  const newChildQ = dstWorldQ.clone().multiply(srcQL_root.clone().invert());
  childObj.quaternion.copy(newChildQ);

  const srcWorldOffset = srcPL_root.clone().applyQuaternion(newChildQ);
  const newChildPos = dstWorldPos.clone().sub(srcWorldOffset);
  childObj.position.copy(newChildPos);

  // push to server
  // IMPORTANT: downstream pose updates may overwrite the renderer orientation.
  // Therefore we must include the *actual* rotation in the pose, not zeros.
  const rod = window.quaternionToRodriguesDeg ? window.quaternionToRodriguesDeg(childObj.quaternion) : [0,0,0];
  const pose = [childObj.position.x, childObj.position.y, childObj.position.z, rod[0]||0, rod[1]||0, rod[2]||0];
  // (we keep rx/ry/rz at 0 because renderer uses quaternion; Display uses rodrigues; ok for builder)
	  const attach = {
	    parent_name: ownerName,
	    parent_solid: __resolveSolidKey(targetObj, __prefParentSolid) || targetObj.userData?.solidName || null,
	    parent_anchor: anchorName,
	    parent_anchor_key: anchorName,
	    child_solid: __resolveSolidKey(childObj, window.builderState.pending.childSolid) || childObj.userData?.solidName || null,
	    child_anchor: window.builderState.pending.sourceAnchor,
	    child_anchor_key: window.builderState.pending.sourceAnchor,
	    offset: [0,0,0,0,0,0]
	  };

  // Preserve existing metadata (especially type/options) when creating an attach.
  // IMPORTANT: pending.type can be undefined in some flows; never overwrite a known type with undefined.
  const __curMeta = window.builderState.components[childName] || {};
  const __t = window.builderState.pending?.type || __curMeta.type;
  window.builderState.components[childName] = Object.assign({}, __curMeta, (__t ? { type: __t } : {}), { attach: attach });

  // Undo step: attaching
  const __nextMeta = __deepClone(window.builderState.components[childName] || null);
  const __nextPose = pose ? __deepClone(pose) : null;
  const __op = (window.builderState.pending && window.builderState.pending.op) ? window.builderState.pending.op : "anchor";
  const __spec0 = __deepClone(window.builderState.specs?.[childName] || {});
  try {
    const merged = __maybeMergeCreateAttach({ kind: "attach", op: __op, name: childName, prevMeta: __prevMeta, prevPose: __prevPose, nextMeta: __nextMeta, nextPose: __nextPose, spec0: __spec0 });
    __pushUndo(merged);
  } catch (e) {}
socket.emit("upstream_update", {
    [childName]: {
      pose,
      builder: { attach }
    }
  });

  // Builder-only visual fix:
  // Some parent/child sub-solid transforms (and sometimes the child's mesh) finalize
  // a frame later, especially for robot-mounted tools. The simulation is correct,
  // but the initial Builder snap can look slightly "floating" until any later
  // transform (like rotate) forces a re-snap.
  //
  // Re-apply the snap on the next frame (and once more) using the recorded attach
  // solids/anchors so the very first render lands in the correct place.
  try {
    const __a = attach;
    const __cn = childName;
    const __pn = ownerName;
    const __resnap = () => {
      try {
        __snapChildToParentAnchor(
          __cn,
          __pn,
          __a.parent_anchor,
          __a.child_solid,
          __a.child_anchor,
          __a.offset,
          __a.parent_solid
        );
      } catch (e) {}
    };
    // two frames covers late-loaded meshes and any post-attach parent transform update
    requestAnimationFrame(() => { __resnap(); requestAnimationFrame(__resnap); });
  } catch (e) {}

  if (window.builderState.components[childName]?.type === "fixture_plate") {
    window.builderState.lastFixturePlate = childName;
  }

  window.builderState.mode = "IDLE";
  window.builderState.pending = null;
  window.builderState.targetName = null;
  showToast("Snapped!");
  // After completing a joint, hide anchors + clear selection to reduce confusion.
  try { clearAnchors(); } catch(e) {}
  try { setSelected(null); } catch(e) {}
  try { closeAnchorPickPanel(); } catch(e) {}

}

window.handleAnchorPick = handleAnchorPick;

// Internal: snap a child component to a parent anchor WITHOUT going through UI state machine.
// Uses the same math as handleAnchorPick().
// NOTE: Some objects (especially plates) store anchors per-solid (anchorsBySolid). When we are
// snapping, we must look up anchors on the *intended* solid, not just the object's current
// userData.anchors (which is usually the first solid).
function __snapChildToParentAnchor(childName, parentName, parentAnchor, childSolid, childAnchor, offsetArr=null, parentSolid=null) {
  const childObj = objectsByName.get(childName);
  const parentObj = objectsByName.get(parentName);
  if (!childObj || !parentObj) throw new Error("snap: missing child/parent object");

  // Some CADs name anchors inconsistently (e.g. "A4" vs "hole_A4" vs "hole-A4").
  // We accept the canonical name in config ("A4") but resolve to the actual key at snap-time.
  function __canonKey(s) {
    if (!s) return null;
    const t = String(s).trim();
    // strip common prefixes
    const cleaned = t.replace(/^hole[ _-]?/i, "").replace(/^anchor[ _-]?/i, "");
    const m = cleaned.match(/^([A-Za-z])[ _-]?(\d{1,4})$/);
    if (!m) return null;
    const L = m[1].toUpperCase();
    const N = parseInt(m[2], 10);
    if (!(L >= "A" && L <= "Z")) return null;
    if (!(N >= 0 && N <= 500)) return null;
    return `${L}${N}`;
  }
  function __resolveAnchorKey(anchors, desiredName) {
    if (!anchors || typeof anchors !== "object") return { key: desiredName, arr: null };
    if (anchors[desiredName]) return { key: desiredName, arr: anchors[desiredName] };

    // try common variants
    const d = String(desiredName);
    const variants = [
      `hole_${d}`,
      `hole-${d}`,
      `hole${d}`,
      `anchor_${d}`,
      `anchor-${d}`
    ];
    for (const v of variants) if (anchors[v]) return { key: v, arr: anchors[v] };

    // try canonical match against all keys
    const want = __canonKey(desiredName);
    if (want) {
      for (const k of Object.keys(anchors)) {
        if (__canonKey(k) === want) return { key: k, arr: anchors[k] };
      }
    }
    return { key: desiredName, arr: null };
  }

    function __getAnchorsForObj(obj, preferredSolid=null) {
    const ud = obj?.userData || {};
    const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;
    // If UI selected a solid, use that solid's anchors even if ud.anchors exists.
    if (preferredSolid && ab) {
      if (ab[preferredSolid]) return ab[preferredSolid];
      const want = String(preferredSolid).toLowerCase();
      const keys = Object.keys(ab);
      const exactCI = keys.find(k => String(k).toLowerCase() === want);
      if (exactCI && ab[exactCI]) return ab[exactCI];
      const contains = keys.find(k => String(k).toLowerCase().includes(want) || want.includes(String(k).toLowerCase()));
      if (contains && ab[contains]) return ab[contains];
    }
    if (ud.anchors && typeof ud.anchors === "object" && Object.keys(ud.anchors).length) return ud.anchors;
    if (!ab) return {};
    const solid = (ud.solidName && ab[ud.solidName]) ? ud.solidName : (ab["solid_0"] ? "solid_0" : Object.keys(ab)[0]);
    return (solid && ab[solid]) ? ab[solid] : {};
  }


	  // Resolve actual solid keys so attach records a real solid name.
	  const __childSolidResolved = __resolveSolidKey(childObj, childSolid) || childObj.userData?.solidName || null;
	  const __parentSolidResolved = __resolveSolidKey(parentObj, parentSolid) || parentObj.userData?.solidName || null;
	
	  const childAnchors = __getAnchorsForObj(childObj, __childSolidResolved);
	  const parentAnchors = __getAnchorsForObj(parentObj, __parentSolidResolved);

  const srcHit = __resolveAnchorKey(childAnchors, childAnchor);
  const dstHit = __resolveAnchorKey(parentAnchors, parentAnchor);

  // Persist resolved anchor keys so subsequent rotate/snap uses the same exact anchor key
  // (prevents jumping between equivalent keys like "A1" vs "hole_A1").
  const __childAnchorKey = srcHit.key || childAnchor;
  const __parentAnchorKey = dstHit.key || parentAnchor;

  const srcArr = srcHit.arr;
  const dstArr = dstHit.arr;
  if (!srcArr) throw new Error(`snap: child anchor not found (${childAnchor})`);
  if (!dstArr) throw new Error(`snap: parent anchor not found (${parentAnchor})`);

  const srcPL = new THREE.Vector3(srcArr[0], srcArr[1], srcArr[2]);
  const srcQL = rodriguesDegToQuaternion(srcArr[3], srcArr[4], srcArr[5]);
  const dstPL = new THREE.Vector3(dstArr[0], dstArr[1], dstArr[2]);
  const dstQL = rodriguesDegToQuaternion(dstArr[3], dstArr[4], dstArr[5]);

  // If anchors are defined in a specific solid's local frame (multi-solid assemblies),
  // convert them into the component-root local frame using the solid holder transform.
  function __solidAnchorToRoot(obj, solidKey, pLocal, qLocal) {
    try {
      if (!solidKey) return { p: pLocal, q: qLocal };
      const holder = obj.getObjectByName ? obj.getObjectByName(String(solidKey)) : null;
      if (!holder || holder === obj) return { p: pLocal, q: qLocal };
      const pW = holder.localToWorld(pLocal.clone());
      const pRoot = obj.worldToLocal(pW.clone());
      const hW = new THREE.Quaternion();
      const oW = new THREE.Quaternion();
      holder.getWorldQuaternion(hW);
      obj.getWorldQuaternion(oW);
      const qW = hW.clone().multiply(qLocal);
      const qRoot = oW.clone().invert().multiply(qW);
      return { p: pRoot, q: qRoot };
    } catch (e) {
      return { p: pLocal, q: qLocal };
    }
  }

	  const __srcX = __solidAnchorToRoot(childObj, __childSolidResolved, srcPL, srcQL);
  const srcPL_root = __srcX.p;
  const srcQL_root = __srcX.q;

	  const __dstX = __solidAnchorToRoot(parentObj, __parentSolidResolved, dstPL, dstQL);
  const dstPL_root = __dstX.p;
  const dstQL_root = __dstX.q;

  const dstWorldPos = parentObj.localToWorld(dstPL_root.clone());
  const parentWorldQ = new THREE.Quaternion();
  parentObj.getWorldQuaternion(parentWorldQ);

  // Base target orientation: parentWorld * parentAnchorLocal
  let dstWorldQ = parentWorldQ.clone().multiply(dstQL_root);

  // IMPORTANT: Config "offset" rotations are defined about the *anchor frame*, not the
  // object's center. That means rotation should happen around the anchor point.
  // We implement this by composing the offset rotation into the target anchor frame
  // BEFORE solving for the child quaternion.
  //
  // offsetArr = [x,y,z,rx,ry,rz] where the last three are treated like the rest of the
  // system (Rodrigues vector in degrees).
  if (Array.isArray(offsetArr) && offsetArr.length >= 6) {
    const qOff = rodriguesDegToQuaternion(offsetArr[3]||0, offsetArr[4]||0, offsetArr[5]||0);
    dstWorldQ = dstWorldQ.clone().multiply(qOff);
  }

  const newChildQ = dstWorldQ.clone().multiply(srcQL_root.clone().invert());
  childObj.quaternion.copy(newChildQ);

  const srcWorldOffset = srcPL_root.clone().applyQuaternion(newChildQ);
  const newChildPos = dstWorldPos.clone().sub(srcWorldOffset);
  childObj.position.copy(newChildPos);

  // apply optional offset in parent frame (XYZ + RPY) if provided
  if (Array.isArray(offsetArr) && offsetArr.length >= 3) {
    const off = new THREE.Vector3(offsetArr[0]||0, offsetArr[1]||0, offsetArr[2]||0);
    // offset is in parent local frame
    const offW = off.applyQuaternion(parentWorldQ);
    childObj.position.add(offW);
  }

  // Downstream updates can overwrite orientation, so include real rotation.
  const rod = (window.quaternionToRodriguesDeg)
    ? window.quaternionToRodriguesDeg(childObj.quaternion)
    : [0,0,0];
  const pose = [childObj.position.x, childObj.position.y, childObj.position.z, rod[0]||0, rod[1]||0, rod[2]||0];
	  const attach = {
    parent_name: parentName,
	    parent_solid: __parentSolidResolved || parentSolid || parentObj.userData?.solidName || null,
    parent_anchor: parentAnchor,
    parent_anchor_key: __parentAnchorKey,
	    child_solid: __childSolidResolved || childSolid || childObj.userData?.solidName || null,
    child_anchor: childAnchor,
    child_anchor_key: __childAnchorKey,
    offset: Array.isArray(offsetArr) ? offsetArr.slice(0,6) : [0,0,0,0,0,0]
  };

  // persist in builder state + on object
  window.builderState.components[childName] = Object.assign({}, window.builderState.components[childName]||{}, { attach });
  if (childObj.userData) childObj.userData.builderAttach = attach;

  try {
    socket.emit("upstream_update", {
      [childName]: { pose, builder: { attach } }
    });
  } catch (e) {
    console.warn("snap: upstream_update failed", e);
  }

  return attach;
}

// Helper: normalize anchor keys like "A_1" / "a-1" -> "A1".
function __normalizeAlphaNumAnchorKey(s) {
  if (!s) return null;
  const t = String(s).trim();
  // extract first letter + trailing number
  const m = t.match(/([A-Za-z])\s*[-_ ]*\s*(\d{1,4})/);
  if (!m) return null;
  const L = m[1].toUpperCase();
  const N = parseInt(m[2], 10);
  if (!Number.isFinite(N)) return null;
  if (L < "A" || L > "Z") return null;
  if (N < 1 || N > 500) return null;
  return `${L}${N}`;
}

function __alphaToIdx(ch) { return ch.charCodeAt(0) - 65; }
function __idxToAlpha(i) { return String.fromCharCode(65 + i); }


function toYamlString(obj) {
  // Small YAML serializer (avoids deps)
  // Assumes obj is simple (dict/list/scalars).
  const lines = [];
  function w(key, val, indent) {
    const pad = " ".repeat(indent);
    if (val === null || val === undefined) return;
    if (Array.isArray(val)) {
      lines.push(`${pad}${key}: [${val.map(v => typeof v === "string" ? JSON.stringify(v) : v).join(", ")}]`);
    } else if (typeof val === "object") {
      lines.push(`${pad}${key}:`);
      for (const [k2, v2] of Object.entries(val)) w(k2, v2, indent + 2);
    } else if (typeof val === "string") {
      lines.push(`${pad}${key}: ${JSON.stringify(val)}`);
    } else {
      lines.push(`${pad}${key}: ${val}`);
    }
  }
  for (const [k, v] of Object.entries(obj)) w(k, v, 0);
  return lines.join("\n") + "\n";
}

function buildConfigObject() {
  // Build the config from what the user actually spawned/anchored.
  // NOTE: We do NOT inject any default cores/robots. If you want a core,
  // spawn it in the builder so it appears here.
  const cfg = {};

  // Builder components
  const entries = [];
  for (const [name, meta] of Object.entries(window.builderState.components)) {
    if (!meta) continue;
    const out = { type: meta.type };

	// NOTE: Do not inject core defaults here.
	// If the user wants has_rail/has_toolchanger/toolchanger_output/ip/robot_attach,
	// they should be set at spawn-time (options) so the builder stays truthful to the scene.
    // Copy any additional options captured at create-time
    for (const [k, v] of Object.entries(meta)) {
      if (k === "type" || k === "attach") continue;
      out[k] = v;
    }

    // Core backward/forward compatibility:
    // Some core versions use `has_toolchanger` while others use `has_tool_changer`.
    // Emit BOTH (and keep them in sync) but ONLY for core.
    if (String(out.type) === "core") {
      if (out.has_tool_changer === undefined && out.has_toolchanger !== undefined) {
        out.has_tool_changer = out.has_toolchanger;
      }
      if (out.has_toolchanger === undefined && out.has_tool_changer !== undefined) {
        out.has_toolchanger = out.has_tool_changer;
      }
    }


    if (meta.attach) {
      // Ensure 6DOF offset always exists for consistency
      if (!meta.attach.offset) meta.attach.offset = [0,0,0,0,0,0];
      out.attach = meta.attach;
    }

    // Normalize the first core name to "core" (templates use "core", not "core_1").
// If user has an older config/session where the first core is "core_1", save it as "core".
let saveName = name;
if (String(out.type).toLowerCase() === "core" && saveName === "core_1" && !(window.builderState.components && window.builderState.components["core"])) {
  saveName = "core";
}
entries.push([saveName, out]);
  }

  // Ordering rule: put any cores at the very top of the YAML.
  // This keeps configs clean when you have core_1, core_2, etc.
  // We treat something as a "core" if either:
  //   - name starts with "core" (core, core_1, core2...)
  //   - or type === "core"
  const isCore = (name, out) => {
    const n = String(name || "").toLowerCase();
    const t = String(out?.type || "").toLowerCase();
    return n === "core" || n.startsWith("core_") || n.startsWith("core") || t === "core";
  };

  entries.sort((a, b) => {
    const ac = isCore(a[0], a[1]) ? 0 : 1;
    const bc = isCore(b[0], b[1]) ? 0 : 1;
    if (ac !== bc) return ac - bc;
    // stable-ish alphabetical within group
    return String(a[0]).localeCompare(String(b[0]));
  });

  for (const [name, out] of entries) cfg[name] = out;

  return cfg;
}

function saveConfig() {
  const cfg = buildConfigObject();
  const yamlText = toYamlString(cfg);

  const blob = new Blob([yamlText], { type: "text/yaml" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "config.yaml";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);

  showToast("Downloaded config.yaml");
}


ensureBuilderBar();

      // --- Animate (keep anchors & badges sticky) ---
      function animate() {
        controls.update();
        updateAnchorsNow();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    await getVersion();
    boot();
  

// --- Pattern Fill (plates) ---
async function patternFromPlate() {
  try { window.showBanner('Pattern: looking for template at A1… (Esc to cancel)', () => { try{window.hideBanner();}catch(e){} }); } catch(e) {}
  console.log('[pattern] start', window.builderState.selectedName, window.builderState.selectedTypeName);
  window.showToast('Pattern start');
  if (typeof window.spawnComponent !== 'function') {
    window.showToast('Pattern error: spawnComponent not ready (page still loading).');
    try { window.hideBanner(); } catch(e) {}
    return;
  }
  const plateName = window.builderState.selectedName;
  const plateType = (window.builderState.selectedTypeName || "");

  if (!plateName) { window.showToast("Select a plate first."); return; }
  if (!(plateType && plateType.startsWith("plate_"))) {
    window.showToast("Select a plate_... object to pattern.");
  try { window.hideBanner(); } catch(e) {}
    return;
  }

  // Require a template object already mounted at A1 (supports nested anchoring chains)
  const TEMPLATE_ANCHOR = "A1";
  let templateName = null;

  function __canonA1(raw) {
    const s = String(raw || "");
    const cleaned = s.replace(/^hole[ _-]?/i, "").replace(/^anchor[ _-]?/i, "");
    const m = cleaned.match(/^([A-Za-z])[ _-]?(\d+)$/);
    return m ? (m[1].toUpperCase() + String(parseInt(m[2], 10))) : s.toUpperCase();
  }

  // If an object is anchored to another anchored object, walk up the attach chain until we
  // hit the plate, and use that plate anchor for template detection.
  function __findPlateAnchorInChain(objName) {
    let cur = objName;
    for (let i = 0; i < 32; i++) {
      const meta = window.builderState.components?.[cur];
      const at = meta && meta.attach ? meta.attach : null;
      if (!at) return null;
      if (at.parent_name === plateName) return at.parent_anchor || null;
      cur = at.parent_name;
      if (!cur) return null;
    }
    return null;
  }

  for (const [n, cfg] of Object.entries(window.builderState.components || {})) {
    const direct = cfg && cfg.attach ? cfg.attach : null;
    const plateAnchor = direct && direct.parent_name === plateName ? direct.parent_anchor : __findPlateAnchorInChain(n);
    if (!plateAnchor) continue;
    if (__canonA1(plateAnchor) === TEMPLATE_ANCHOR) { templateName = n; break; }
  }

  if (!templateName) {
    window.showToast(`No object mounted at ${TEMPLATE_ANCHOR}. Place one there first, then Pattern.`);
    return;
  }

  const plateObj = window.objectsByName.get(plateName);
  if (!plateObj || !plateObj.userData) {
    window.showToast("Plate not found in scene.");
    return;
  }

  // Plates sometimes store anchors in anchorsBySolid instead of anchors.
  // Pull the active solid's anchors if available.
  function __getPlateAnchors(obj) {
    const ud = obj?.userData || {};
    if (ud.anchors && typeof ud.anchors === "object") return ud.anchors;
    const ab = ud.anchorsBySolid && typeof ud.anchorsBySolid === "object" ? ud.anchorsBySolid : null;
    if (!ab) return null;
    const solid = ud.solidName && ab[ud.solidName] ? ud.solidName : (ab["solid_0"] ? "solid_0" : Object.keys(ab)[0]);
    return solid ? (ab[solid] || null) : null;
  }

  const plateAnchorsRaw = __getPlateAnchors(plateObj);
  if (!plateAnchorsRaw) {
    window.showToast("Plate anchors not available (anchors/anchorsBySolid missing)." );
    return;
  }

  // Canonicalize plate hole anchors to "A1".."Z500".
  // We map canonical -> actual key used in the plate anchor dictionary.
  function __canonHoleName(k) {
    if (!k || typeof k !== "string") return null;
    // Accept A1, A_1, A-1, hole_A1, hole-A1, holeA1
    const cleaned = k.replace(/^hole[ _-]?/i, "").replace(/^anchor[ _-]?/i, "");
    const m = cleaned.match(/^([A-Za-z])[ _-]?(\d+)$/);
    if (!m) return null;
    const letter = m[1].toUpperCase();
    const num = parseInt(m[2], 10);
    if (!(letter >= "A" && letter <= "Z")) return null;
    if (!(num >= 1 && num <= 500)) return null;
    return `${letter}${num}`;
  }

  const plateKeyByCanon = new Map();
  for (const k of Object.keys(plateAnchorsRaw)) {
    const c = __canonHoleName(String(k));
    if (!c) continue;
    if (!plateKeyByCanon.has(c)) plateKeyByCanon.set(c, k);
  }

  // Build the exact fill list A1..Z500 but only for anchors that actually exist on this plate.
  const holesCanon = [];
  for (let li = 0; li < 26; li++) {
    const letter = String.fromCharCode(65 + li);
    for (let n = 1; n <= 500; n++) {
      const c = `${letter}${n}`;
      if (plateKeyByCanon.has(c)) holesCanon.push(c);
    }
  }

  if (!holesCanon.length) {
    window.showToast("No plate anchors found in the A1..Z500 range on this plate.");
    return;
  }

  // Determine which plate anchors are already occupied (A1..Z500 only)
  const occupied = new Set();
  for (const [n, cfg] of Object.entries(window.builderState.components || {})) {
    const a = cfg && cfg.attach;
    if (!a) continue;
    if (a.parent_name !== plateName) continue;
    const raw = String(a.parent_anchor || "");
    const canon = __canonHoleName(raw);
    if (!canon) continue;
    occupied.add(raw);
    occupied.add(canon);
  }

  const tmplCfg = window.builderState.components[templateName] || {};
  const tmplType = tmplCfg.type;
  const tmplAttach = tmplCfg.attach || {};
  const childAnchor = tmplAttach.child_anchor || "center";
  const childSolid = tmplAttach.child_solid || "solid_0";

  // carry forward checkbox options from the template (we store options as top-level keys)
  const templateOptions = {};
  for (const [k, v] of Object.entries(tmplCfg)) {
    if (k === "type" || k === "attach" || k === "pose" || k === "builder" || k === "simulation") continue;
    if (typeof v === "boolean") templateOptions[k] = v;
  }

  // Get plate hole anchors (restricted to A1..Z500 that actually exist on this plate)
  const holes = holesCanon.map(c => plateKeyByCanon.get(c)).filter(Boolean);

  // Fill all unoccupied holes (skip the template slot and any already-used)
let placed = 0;
  // NEW behavior: pattern is no longer an atomic undo step.
  // Each spawned instance behaves like a normal spawn+joint:
  // - Undo removes the LAST spawned instance
  // - Repeated undo walks backwards through the pattern instances
  window.showBanner(`Patterning ${tmplType} into ${holes.length} holes…`, null);
  for (const hole of holes) {
    const canon = __canonHoleName(String(hole)) || String(hole).toUpperCase();
    if (canon === TEMPLATE_ANCHOR) continue;
    if (occupied.has(String(hole)) || occupied.has(canon)) continue;

    // spawn a fresh instance (this pushes a normal {kind:"create"} undo entry)
    const newName = await window.spawnComponent(tmplType, null, templateOptions);

    // programmatically snap it using existing joint math
    window.builderState.mode = "PICK_TARGET_ANCHOR";
    window.builderState.pending = { name: newName, type: tmplType, sourceAnchor: childAnchor, childSolid };
    window.builderState.targetName = plateName;

    // this attach is eligible to merge with the create into {kind:"create_attach"}
    window.handleAnchorPick(plateName, hole);

    placed += 1;

    // keep UI responsive
    await new Promise(r => setTimeout(r, 0));
  }
  try { window.hideBanner(); } catch(e) {}
  window.showToast(`Pattern placed ${placed} item(s).`);
window.showToast(`Pattern placed ${placed} item(s).`);
}

function openPatternSourceAnchorMenu(sourceName, anchorsBySolid) {
  try { window.hideBanner(); } catch(e) {}

  // choose which anchor on the source object will be placed into each plate hole
  const old = document.getElementById("patternSourceAnchorMenu");
  if (old) old.remove();

  const menu = document.createElement("div");
  menu.id = "patternSourceAnchorMenu";
  menu.style.position = "fixed";
  menu.style.left = "50%";
  menu.style.top = "50%";
  menu.style.transform = "translate(-50%, -50%)";
  menu.style.width = "520px";
  menu.style.maxWidth = "92vw";
  menu.style.maxHeight = "80vh";
  menu.style.overflowY = "auto";
  menu.style.background = "rgba(20,20,20,0.95)";
  menu.style.border = "1px solid rgba(255,255,255,0.10)";
  menu.style.borderRadius = "16px";
  menu.style.padding = "14px";
  menu.style.zIndex = "10020";
  menu.style.color = "#fff";

  const title = document.createElement("div");
  title.textContent = "Pattern: choose source anchor";
  title.style.fontWeight = "700";
  title.style.marginBottom = "10px";
  menu.appendChild(title);

  const solids = Object.keys(anchorsBySolid || {});
  let solid = solids.length ? solids[0] : "solid_0";
  let anchors = anchorsBySolid?.[solid] || {};

  // if multiple solids, let user pick
  if (solids.length > 1) {
    const solidRow = document.createElement("div");
    solidRow.style.display = "flex";
    solidRow.style.gap = "10px";
    solidRow.style.alignItems = "center";
    solidRow.style.marginBottom = "10px";

    const lab = document.createElement("div");
    lab.textContent = "Solid:";
    lab.style.opacity = "0.85";
    lab.style.width = "60px";
    solidRow.appendChild(lab);

    const sel = document.createElement("select");
    sel.style.flex = "1";
    sel.style.padding = "8px 10px";
    sel.style.borderRadius = "10px";
    sel.style.border = "1px solid rgba(255,255,255,0.12)";
    sel.style.background = "rgba(0,0,0,0.25)";
    sel.style.color = "#fff";
    for (const s of solids) {
      const opt = document.createElement("option");
      opt.value = s;
      opt.textContent = s;
      sel.appendChild(opt);
    }
    sel.onchange = () => {
      solid = sel.value;
      anchors = anchorsBySolid?.[solid] || {};
      renderAnchorButtons();
    };
    solidRow.appendChild(sel);
    menu.appendChild(solidRow);
  }

  const btnWrap = document.createElement("div");
  btnWrap.style.display = "grid";
  btnWrap.style.gridTemplateColumns = "repeat(2, minmax(0, 1fr))";
  btnWrap.style.gap = "8px";
  menu.appendChild(btnWrap);

  function renderAnchorButtons() {
    btnWrap.innerHTML = "";
    const names = Object.keys(anchors || {});
    if (!names.length) {
      const none = document.createElement("div");
      none.textContent = "No anchors on this object.";
      none.style.opacity = "0.75";
      btnWrap.appendChild(none);
      return;
    }

    // Prefer center if present
    names.sort((a,b) => (a==="center" ? -1 : b==="center" ? 1 : a.localeCompare(b)));

    for (const a of names) {
      const b = document.createElement("button");
      b.textContent = a;
      b.style.padding = "10px 12px";
      b.style.borderRadius = "12px";
      b.style.border = "1px solid rgba(255,255,255,0.12)";
      b.style.background = "rgba(255,255,255,0.06)";
      b.style.color = "#fff";
      b.style.textAlign = "left";
      b.onclick = () => {
        menu.remove();
        const plateName = window.builderState.pattern?.plateName;
        if (!plateName) return;
        window.builderState.pattern.sourceName = sourceName;
        window.builderState.pattern.sourceSolid = solid;
        window.builderState.pattern.sourceAnchor = a;
        runPatternFill();
      };
      btnWrap.appendChild(b);
    }
  }
  renderAnchorButtons();

  const cancel = document.createElement("button");
  cancel.textContent = "Cancel";
  cancel.style.marginTop = "12px";
  cancel.style.width = "100%";
  cancel.style.padding = "10px 12px";
  cancel.style.borderRadius = "12px";
  cancel.style.border = "1px solid rgba(255,255,255,0.12)";
  cancel.style.background = "rgba(0,0,0,0.30)";
  cancel.style.color = "#fff";
  cancel.onclick = () => {
    window.builderState.mode = "IDLE";
    window.builderState.pattern = null;
    menu.remove();
  };
  menu.appendChild(cancel);

  document.body.appendChild(menu);
}


// helper: detect hole-like anchors on plates (A1..Z999, or numeric 0..500, etc.)
function __isPlateHoleAnchor(name) {
  if (!name || typeof name !== "string") return false;
  // common non-hole anchors to ignore
  const bad = ["center","place","tcp","tool_connection"];
  if (bad.includes(name)) return false;
  // letter+number: A1, f15, etc (also allow A_1, A-1)
  if (/^[A-Za-z][_-]?\d+$/.test(name)) return true;
  // numeric: 0,1,2... (limit later)
  if (/^\d+$/.test(name)) return true;
  return false;
}

// sort holes in a stable “human” order: A1..A99..B1.. then numeric
function __anchorSortKey(name) {
  // returns [group, letterIndex, number]
  if (/^[A-Za-z][_-]?\d+$/.test(name)) {
    const m = name.match(/^([A-Za-z])[ _-]?(\d+)$/);
    const li = m ? (m[1].toUpperCase().charCodeAt(0) - 65) : 99;
    const num = m ? parseInt(m[2],10) : 0;
    return [0, li, num];
  }
  if (/^\d+$/.test(name)) {
    return [1, 0, parseInt(name,10)];
  }
  return [2, 0, 0];
}

async function runPatternFill() {
  const p = window.builderState.pattern;
  if (!p?.plateName || !p?.sourceName || !p?.sourceAnchor) return;

  const plateObj = window.objectsByName.get(p.plateName);
  const srcObj = window.objectsByName.get(p.sourceName);
  if (!plateObj || !srcObj) return;

  const plateAnchors = plateObj.userData?.anchors || {};
  const plateHoleNames = Object.keys(plateAnchors)
    .filter(__isPlateHoleAnchor)
    .filter(n => {
      if (/^\d+$/.test(n)) return parseInt(n,10) <= 500;
      const m = n.match(/^[A-Za-z][ _-]?(\d+)$/);
      if (m) return parseInt(m[1],10) <= 500;
      return true;
    });
  plateHoleNames.sort((a,b) => {
    const ka = __anchorSortKey(a), kb = __anchorSortKey(b);
    for (let i=0;i<3;i++) if (ka[i] !== kb[i]) return ka[i] - kb[i];
    return String(a).localeCompare(String(b));
  });

  if (!plateHoleNames.length) {
    window.showToast("No hole-style anchors found on this plate.");
    window.builderState.mode = "IDLE";
    window.builderState.pattern = null;
    return;
  }

  // Determine source type from builder meta OR scene userData
  let srcType = window.builderState.components[p.sourceName]?.type || "";
  if (!srcType) {
    try {
      const so = window.objectsByName.get(p.sourceName);
      srcType = so?.userData?.typeName || so?.userData?.type || "";
    } catch(e) {}
  }
  if (!srcType) { window.showToast("Source object type unknown."); return; }

  // Use same checkbox options as the source object (only bools are stored now)
  const srcOptions = {};
  const meta = window.builderState.components[p.sourceName] || {};
  for (const k in meta) {
    if (k === "type" || k === "attach" || k === "simulation") continue;
    if (typeof meta[k] === "boolean") srcOptions[k] = meta[k];
  }

  // Cache blueprint once for speed
  let blueprint = null;
  try {
    const res = await fetch("/api/instantiate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ type: srcType, options: srcOptions })
    });
    const js = await res.json();
    if (js && js.ok) blueprint = js.blueprint;
  } catch(e) {}

  if (!blueprint) {
    window.showToast("Failed to instantiate pattern object.");
    window.builderState.mode = "IDLE";
    window.builderState.pattern = null;
    return;
  }

  // Build meshes + anchorsBySolid from blueprint
  const anchorsBySolid = {};
  const meshes = [];
  for (const s of (blueprint.solids || [])) {
    if (s?.solid && s?.anchors) anchorsBySolid[s.solid] = s.anchors;
    if (s?.glb) meshes.push({ meshUrl: s.glb, pose: s.pose || [0,0,0,0,0,0], solidName: s.solid });
  }
  const childSolid = p.sourceSolid || (Object.keys(anchorsBySolid)[0] || "solid_0");
  const childAnchors = anchorsBySolid[childSolid] || {};
  const srcArr = childAnchors[p.sourceAnchor];
  if (!srcArr) {
    window.showToast("Selected source anchor not found on instantiated object.");
    window.builderState.mode = "IDLE";
    window.builderState.pattern = null;
    return;
  }


  // Build a set of already-occupied plate anchors so we don't double-place.
  const occupied = new Set();
  try {
    for (const [n, m] of Object.entries(window.builderState.components || {})) {
      const at = m?.attach;
      if (!at) continue;
      if (at.parent_name === p.plateName && at.parent_anchor) occupied.add(String(at.parent_anchor));
    }
  } catch(e) {}

  
  // Ensure we never overwrite an existing component name (critical for correct pattern-undo behavior).
  // If the seed is e.g. tube_1 and next[tube] is still 1, the first clone would become tube_1 and overwrite the seed.
  try {
    const comps = window.builderState.components || {};
    let maxIdx = 0;
    const reName = new RegExp("^" + srcType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "_(\\d+)$");
    for (const k of Object.keys(comps)) {
      const m = String(k).match(reName);
      if (m) maxIdx = Math.max(maxIdx, parseInt(m[1], 10) || 0);
    }
    if (!window.builderState.next) window.builderState.next = {};
    const cur = window.builderState.next[srcType] || 1;
    window.builderState.next[srcType] = Math.max(cur, maxIdx + 1);
  } catch(e) {}

// place many instances
let count = 0;
  // NEW behavior: do NOT record a single atomic pattern undo.
  // Each instance behaves like a normal spawn+joint so Ctrl+Z removes them one-by-one (last created first).
  window.showBanner(`Patterning into ${targets.length} anchors…`, null);

  for (const tgt of targets) {
    try {
      const name = await window.spawnComponent(srcType, null, srcOptions);
      // Snap it using existing anchor pick logic (this attach can merge with the create into {kind:"create_attach"}).
      window.builderState.mode = "PICK_TARGET_ANCHOR";
      window.builderState.pending = { name, type: srcType, sourceAnchor: p.sourceAnchor, childSolid: p.childSolid };
      window.builderState.targetName = p.plateName;
      window.handleAnchorPick(p.plateName, tgt);
      count++;
    } catch (e) {
      console.error(e);
    }
    await new Promise(r => setTimeout(r, 0));
  }

  try { window.hideBanner(); } catch(e) {}
  window.showToast(`Patterned ${count} instances on ${p.plateName}.`);
  window.builderState.mode = "IDLE";
  window.builderState.pattern = null;
}

// ==============================
// Fusion-style Rectangular Pattern
// ==============================

function __rpGetAnchorsForObj(obj) {
  const ud = obj?.userData || {};
  if (ud.anchors && typeof ud.anchors === "object" && Object.keys(ud.anchors).length) return ud.anchors;
  const ab = ud.anchorsBySolid && typeof ud.anchorsBySolid === "object" ? ud.anchorsBySolid : null;
  if (!ab) return {};
  const solid = (ud.solidName && ab[ud.solidName])
    ? ud.solidName
    : (ab["solid_0"] ? "solid_0" : Object.keys(ab)[0]);
  return (solid && ab[solid]) ? ab[solid] : {};
}

function __rpAnchorWorldPose(ownerName, anchorName) {
  const owner = objectsByName.get(ownerName);
  if (!owner) return null;
  const anchors = __rpGetAnchorsForObj(owner);
  const arr = anchors ? anchors[anchorName] : null;
  if (!arr || !Array.isArray(arr) || arr.length !== 6) return null;
  const pLocal = new THREE.Vector3(arr[0], arr[1], arr[2]);
  const qLocal = rodriguesDegToQuaternion(arr[3], arr[4], arr[5]);
  const pWorld = owner.localToWorld(pLocal.clone());
  const ownerQ = new THREE.Quaternion();
  owner.getWorldQuaternion(ownerQ);
  const qWorld = ownerQ.clone().multiply(qLocal);
  return { pos: pWorld, quat: qWorld };
}

function __rpChildAnchorLocalPose(childObj, childAnchorName) {
  const anchors = __rpGetAnchorsForObj(childObj);
  const arr = anchors ? anchors[childAnchorName] : null;
  if (!arr || !Array.isArray(arr) || arr.length !== 6) {
    return { pos: new THREE.Vector3(0,0,0), quat: new THREE.Quaternion() };
  }
  return {
    pos: new THREE.Vector3(arr[0], arr[1], arr[2]),
    quat: rodriguesDegToQuaternion(arr[3], arr[4], arr[5])
  };
}

// RectPattern: second anchor selection handler.
// Called when the user clicks an anchor (or chooses from the list) while in RECTPATTERN_PICK_SECOND_ANCHOR.
function rectPatternHandleSecondAnchor(ownerName, anchorName) {
  const rp = window.builderState?.rectPattern;
  const ui = window.builderState?.rectPatternUi;
  if (!rp || !ui || !rp.seedName) { showToast("Pick a seed object first."); return; }
  if (!ownerName || !anchorName) { showToast("Select a valid anchor."); return; }

  const w = __rpAnchorWorldPose(ownerName, anchorName);
  if (!w || !w.pos) { showToast("Anchor not found: " + anchorName); return; }

  rp.bAnchor = {
    ownerName,
    anchorName,
    pos: w.pos.clone(),
    quat: w.quat ? w.quat.clone() : new THREE.Quaternion()
  };
  rp.secondOwnerName = ownerName;

  // Delta is used by the UI validation and also legacy distance-based pattern mode.
  // For grid-fill mode, we still compute this so the "Pick the 2nd anchor" check passes.
  const aPos = (rp.aAnchor && rp.aAnchor.pos) ? rp.aAnchor.pos : null;
  rp.delta = aPos ? rp.bAnchor.pos.clone().sub(aPos) : new THREE.Vector3(0,0,0);

  // UI update
  ui.pointBox.dataset.state = "ok";
  ui.pointBox.textContent = `2nd anchor ✓ (${ownerName}:${anchorName})`;
  ui.pointBox.style.borderColor = "rgba(0,140,0,0.55)";
  ui.pointBox.style.background = "rgba(0,140,0,0.08)";
  ui.pointClear.style.display = "inline-flex";

  window.builderState.mode = "IDLE";
  try { window.hideBanner?.(); } catch(e) {}
  try { clearAnchors?.(); } catch(e) {}
  showToast("2nd anchor set.");
}

function closeRectPatternPanel() {
  try { window.hideBanner?.(); } catch(e) {}
  if (window.builderState) window.builderState.mode = "IDLE";

  const el = document.getElementById("rectPatternPanel");
  if (el) el.remove();
}

function startRectPattern() {
  closeRectPatternPanel();

  // Panel shell
  const panel = document.createElement("div");
  panel.id = "rectPatternPanel";
  panel.style.position = "fixed";
  panel.style.right = "18px";
  panel.style.top = "18px";
  panel.style.width = "360px";
  panel.style.maxHeight = "85vh";
  panel.style.overflow = "auto";
  panel.style.background = "rgba(255,255,255,0.96)";
  panel.style.border = "1px solid rgba(0,0,0,0.12)";
  panel.style.borderRadius = "16px";
  panel.style.boxShadow = "0 18px 60px rgba(0,0,0,0.18)";
  panel.style.padding = "14px";
  panel.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
  panel.style.color = "#111";

  const title = document.createElement("div");
  title.textContent = "Rectangular Pattern";
  title.style.fontWeight = "700";
  title.style.fontSize = "16px";
  title.style.marginBottom = "8px";
  panel.appendChild(title);

  const hint = document.createElement("div");
  hint.style.fontSize = "12px";
  hint.style.opacity = "0.75";
  hint.style.marginBottom = "10px";
  hint.textContent = "Pick a seed object (must be anchored), then pick a 2nd anchor. Enter counts and Fill.";
  panel.appendChild(hint);

  function mkRow(labelText) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";
    row.style.marginBottom = "8px";

    const label = document.createElement("div");
    label.textContent = labelText;
    label.style.width = "110px";
    label.style.fontSize = "12px";
    label.style.opacity = "0.9";
    row.appendChild(label);

    return { row, label };
  }

  function mkSelectBox(placeholder) {
    const wrap = document.createElement("div");
    wrap.style.flex = "1";
    wrap.style.display = "flex";
    wrap.style.alignItems = "center";
    wrap.style.gap = "6px";

    const box = document.createElement("div");
    box.textContent = placeholder;
    box.dataset.state = "empty";
    box.style.flex = "1";
    box.style.cursor = "pointer";
    box.style.userSelect = "none";
    box.style.padding = "10px 10px";
    box.style.borderRadius = "12px";
    box.style.border = "1px solid rgba(0,0,0,0.18)";
    box.style.background = "rgba(0,0,0,0.02)";
    box.style.fontSize = "12px";
    box.style.lineHeight = "1.2";
    box.title = "Click to pick";

    const clearBtn = document.createElement("button");
    clearBtn.textContent = "×";
    clearBtn.style.display = "none";
    clearBtn.style.width = "28px";
    clearBtn.style.height = "28px";
    clearBtn.style.borderRadius = "10px";
    clearBtn.style.border = "1px solid rgba(0,0,0,0.18)";
    clearBtn.style.background = "rgba(255,255,255,0.85)";
    clearBtn.style.cursor = "pointer";
    clearBtn.title = "Clear";

    wrap.appendChild(box);
    wrap.appendChild(clearBtn);
    return { wrap, box, clearBtn };
  }

  // Seed object picker
  const r1 = mkRow("Seed object");
  const seed = mkSelectBox("Select a valid object…");
  r1.row.appendChild(seed.wrap);
  panel.appendChild(r1.row);

  seed.box.addEventListener("click", () => {
    window.builderState.mode = "RECTPATTERN_PICK_OBJECT";
    try { window.showBanner?.("Click a valid anchored object (the one you want to pattern)."); } catch(e) {}
  });
  seed.clearBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    seed.box.dataset.state = "empty";
    seed.box.textContent = "Select a valid object…";
    seed.box.style.borderColor = "rgba(0,0,0,0.18)";
    seed.box.style.background = "rgba(0,0,0,0.02)";
    seed.clearBtn.style.display = "none";
    // also clear rp
    window.builderState.rectPattern = null;
    // reset point
    point.box.dataset.state = "empty";
    point.box.textContent = "Select 2nd anchor…";
    point.box.style.borderColor = "rgba(0,0,0,0.18)";
    point.box.style.background = "rgba(0,0,0,0.02)";
    point.clearBtn.style.display = "none";
    btnAnchorList.disabled = true;
    btnAnchorList.style.opacity = "0.6";
  });

  // Second point picker
  const r2 = mkRow("2nd anchor");
  const point = mkSelectBox("Select 2nd anchor…");
  r2.row.appendChild(point.wrap);
  panel.appendChild(r2.row);

  // Optional: choose anchor from list (enabled after selecting target object for 2nd anchor)
  const r2b = document.createElement("div");
  r2b.style.display = "flex";
  r2b.style.justifyContent = "flex-end";
  r2b.style.marginTop = "-4px";
  r2b.style.marginBottom = "8px";

  const btnAnchorList = document.createElement("button");
  btnAnchorList.textContent = "Choose anchor from list";
  btnAnchorList.disabled = true;
  btnAnchorList.style.padding = "8px 10px";
  btnAnchorList.style.borderRadius = "12px";
  btnAnchorList.style.border = "1px solid rgba(0,0,0,0.18)";
  btnAnchorList.style.background = "rgba(255,255,255,0.9)";
  btnAnchorList.style.cursor = "pointer";
  btnAnchorList.style.fontSize = "12px";
  btnAnchorList.style.opacity = "0.6";
  r2b.appendChild(btnAnchorList);
  panel.appendChild(r2b);

  function __rpOpenAnchorListModal(ownerName) {
    const owner = objectsByName.get(ownerName);
    if (!owner) { showToast("Target object missing."); return; }
    const anchors = __rpGetAnchorsForObj(owner);
    const names = Object.keys(anchors || {}).sort((a,b)=>a.localeCompare(b, undefined, {numeric:true}));
    if (!names.length) { showToast("No anchors on target object."); return; }

    // Overlay
    const overlay = document.createElement("div");
    overlay.id = "rectPatternAnchorListOverlay";
    overlay.style.position = "fixed";
    overlay.style.inset = "0";
    overlay.style.background = "rgba(0,0,0,0.28)";
    overlay.style.zIndex = "999999";
    overlay.addEventListener("click", (e) => { if (e.target === overlay) overlay.remove(); });

    const modal = document.createElement("div");
    modal.style.position = "absolute";
    modal.style.right = "18px";
    modal.style.top = "90px";
    modal.style.width = "360px";
    modal.style.maxHeight = "60vh";
    modal.style.overflow = "hidden";
    modal.style.background = "rgba(255,255,255,0.98)";
    modal.style.border = "1px solid rgba(0,0,0,0.12)";
    modal.style.borderRadius = "16px";
    modal.style.boxShadow = "0 18px 60px rgba(0,0,0,0.22)";
    modal.style.padding = "12px";
    modal.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";

    const h = document.createElement("div");
    h.textContent = `Anchors on ${ownerName}`;
    h.style.fontWeight = "700";
    h.style.marginBottom = "8px";
    modal.appendChild(h);

    const search = document.createElement("input");
    search.type = "text";
    search.placeholder = "Filter anchors…";
    search.style.width = "100%";
    search.style.boxSizing = "border-box";
    search.style.padding = "10px 10px";
    search.style.borderRadius = "12px";
    search.style.border = "1px solid rgba(0,0,0,0.18)";
    search.style.marginBottom = "8px";
    modal.appendChild(search);

    const list = document.createElement("div");
    list.style.maxHeight = "45vh";
    list.style.overflow = "auto";
    list.style.border = "1px solid rgba(0,0,0,0.10)";
    list.style.borderRadius = "12px";
    list.style.background = "rgba(0,0,0,0.02)";
    modal.appendChild(list);

    function render(filterText="") {
      list.innerHTML = "";
      const f = (filterText||"").trim().toLowerCase();
      const shown = names.filter(n => !f || n.toLowerCase().includes(f));
      for (const n of shown) {
        const item = document.createElement("div");
        item.textContent = n;
        item.style.padding = "10px 10px";
        item.style.cursor = "pointer";
        item.style.fontSize = "12px";
        item.style.borderBottom = "1px solid rgba(0,0,0,0.06)";
        item.addEventListener("mouseenter", ()=> item.style.background = "rgba(0,0,0,0.05)");
        item.addEventListener("mouseleave", ()=> item.style.background = "transparent");
        item.addEventListener("click", () => {
          overlay.remove();
          rectPatternHandleSecondAnchor(ownerName, n);
        });
        list.appendChild(item);
      }
      if (!shown.length) {
        const empty = document.createElement("div");
        empty.textContent = "No matches.";
        empty.style.padding = "10px";
        empty.style.fontSize = "12px";
        empty.style.opacity = "0.7";
        list.appendChild(empty);
      }
    }
    render();
    search.addEventListener("input", ()=>render(search.value));

    const foot = document.createElement("div");
    foot.style.display = "flex";
    foot.style.justifyContent = "flex-end";
    foot.style.marginTop = "10px";
    const close = document.createElement("button");
    close.textContent = "Close";
    close.style.padding = "8px 10px";
    close.style.borderRadius = "12px";
    close.style.border = "1px solid rgba(0,0,0,0.18)";
    close.style.background = "rgba(255,255,255,0.9)";
    close.style.cursor = "pointer";
    close.addEventListener("click", ()=>overlay.remove());
    foot.appendChild(close);
    modal.appendChild(foot);

    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    search.focus();
  }

  btnAnchorList.addEventListener("click", (e) => {
    e.stopPropagation();
    const rp = window.builderState.rectPattern;
    if (!rp?.secondOwnerName) { showToast("Pick the target object first."); return; }
    __rpOpenAnchorListModal(rp.secondOwnerName);
  });

  point.box.addEventListener("click", () => {
    const rp = window.builderState.rectPattern;
    if (!rp || !rp.seedName) { showToast("Pick a seed object first."); return; }
    window.builderState.mode = "RECTPATTERN_PICK_SECOND_OBJECT";
    try { window.showBanner?.("Click the target object, then click an anchor on that object."); } catch(e) {}
  });
  point.clearBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    const rp = window.builderState.rectPattern;
    if (rp) { rp.bAnchor = null; rp.delta = null; rp.secondOwnerName = null; }
    point.box.dataset.state = "empty";
    point.box.textContent = "Select 2nd anchor…";
    point.box.style.borderColor = "rgba(0,0,0,0.18)";
    point.box.style.background = "rgba(0,0,0,0.02)";
    point.clearBtn.style.display = "none";
    btnAnchorList.disabled = true;
    btnAnchorList.style.opacity = "0.6";
  });

  // Counts
  const countsWrap = document.createElement("div");
  countsWrap.style.display = "grid";
  countsWrap.style.gridTemplateColumns = "1fr 1fr 1fr";
  countsWrap.style.gap = "8px";
  countsWrap.style.marginTop = "6px";
  // Grid-fill mode: hide count inputs (anchor-based fill)
  countsWrap.style.display = "none";

  function mkCount(labelText) {
    const c = document.createElement("div");
    c.style.display = "flex";
    c.style.flexDirection = "column";
    c.style.gap = "4px";

    const l = document.createElement("div");
    l.textContent = labelText;
    l.style.fontSize = "12px";
    l.style.opacity = "0.9";

    const input = document.createElement("input");
    input.type = "number";
    input.min = "1";
    input.step = "1";
    input.value = "1";
    input.style.padding = "10px 10px";
    input.style.borderRadius = "12px";
    input.style.border = "1px solid rgba(0,0,0,0.18)";
    input.style.background = "rgba(255,255,255,0.9)";
    input.style.fontSize = "12px";

    c.appendChild(l);
    c.appendChild(input);
    return { c, input };
  }

  const cx = mkCount("Count X");
  const cy = mkCount("Count Y");
  const cz = mkCount("Count Z");
  countsWrap.appendChild(cx.c);
  countsWrap.appendChild(cy.c);
  countsWrap.appendChild(cz.c);
  panel.appendChild(countsWrap);

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.justifyContent = "space-between";
  actions.style.gap = "10px";
  actions.style.marginTop = "12px";

  const btnCancel = document.createElement("button");
  btnCancel.textContent = "Cancel";
  btnCancel.style.flex = "1";
  btnCancel.style.padding = "10px 12px";
  btnCancel.style.borderRadius = "12px";
  btnCancel.style.border = "1px solid rgba(0,0,0,0.18)";
  btnCancel.style.background = "rgba(255,255,255,0.9)";
  btnCancel.style.cursor = "pointer";

  const btnFill = document.createElement("button");
  btnFill.textContent = "Fill";
  btnFill.style.flex = "1";
  btnFill.style.padding = "10px 12px";
  btnFill.style.borderRadius = "12px";
  btnFill.style.border = "1px solid rgba(0,0,0,0.18)";
  btnFill.style.background = "rgba(0,0,0,0.88)";
  btnFill.style.color = "white";
  btnFill.style.cursor = "pointer";
  btnFill.style.fontWeight = "700";

  actions.appendChild(btnCancel);
  actions.appendChild(btnFill);
  panel.appendChild(actions);

  btnCancel.addEventListener("click", () => closeRectPatternPanel());

  btnFill.addEventListener("click", async () => {
    const rp = window.builderState.rectPattern;
    if (!rp || !rp.seedName || !rp.aAnchor?.pos) { showToast("Pick a seed object."); return; }
    if (!rp.bAnchor?.pos || !rp.delta) { showToast("Pick the 2nd anchor."); return; }

    // --- Grid fill mode (A1..Z500 style) ---
    // If the seed is anchored to the same target object as the 2nd anchor, and both anchors
    // look like <Letter><Number> (e.g., A1, H12), we fill the entire rectangular range.
    function __normGridKey(s) {
      if (!s) return "";
      return String(s).trim().toUpperCase().replace(/[^A-Z0-9]/g, "");
    }
    function __parseGridKey(s) {
      const k = __normGridKey(s);
      const m = k.match(/^([A-Z])(\d{1,4})$/);
      if (!m) return null;
      const col = m[1].charCodeAt(0) - 65;
      const row = parseInt(m[2], 10);
      if (!(col >= 0 && col <= 25)) return null;
      if (!(row >= 1 && row <= 500)) return null;
      return { col, row, key: `${m[1]}${row}` };
    }
    function __keyFromCR(col, row) {
      const c = String.fromCharCode(65 + col);
      return `${c}${row}`;
    }

    const seedMeta = window.builderState.components?.[rp.seedName] || null;
    const seedObj = objectsByName.get(rp.seedName);
    const seedAttach = seedMeta?.attach || (seedObj?.userData?.builderAttach) || null;

    // If the seed is attached through a chain (tube -> adapter -> plate), find the attach step
    // that directly targets the chosen parent (usually the fixture plate).
    function __findAttachToAncestor(childName, ancestorName) {
      try {
        let cur = childName;
        for (let i = 0; i < 60; i++) {
          const m = window.builderState.components?.[cur] || null;
          const o = objectsByName.get(cur);
          const at = m?.attach || o?.userData?.builderAttach || o?.userData?.attach || null;
          if (!at || !at.parent_name) return null;
          if (at.parent_name === ancestorName) return at;
          cur = at.parent_name;
        }
      } catch(e) {}
      return null;
    }

    // In grid-fill, users often click a seed that is anchored *indirectly* (A1 tube -> adapter -> plate).
    // We allow that by inferring the seed's A1 key from proximity on the chosen target object.
    const gridB = __parseGridKey(rp.bAnchor?.anchorName);

    // The grid we fill is defined by the object you picked the 2nd anchor on.
    // Usually this is the fixture plate. The seed may be attached indirectly to it.
    const targetParentName = rp.bAnchor?.ownerName || null;

    // Try to find the seed's plate-level attachment (seed -> ... -> targetParentName).
    const seedAttachToTarget = (targetParentName && rp.seedName) ? __findAttachToAncestor(rp.seedName, targetParentName) : null;

    let gridA = null;
    if (seedAttachToTarget?.parent_anchor) {
      gridA = __parseGridKey(seedAttachToTarget.parent_anchor);
    } else if (seedAttach?.parent_name && targetParentName && seedAttach.parent_name === targetParentName) {
      // direct attach fallback
      gridA = __parseGridKey(seedAttach?.parent_anchor);
    }
    // If the seed isn't directly anchored to the target parent (or anchor isn't A1-style), infer it.
    if (!gridA && seedObj && targetParentName) {
      try {
        const parentObjGuess = objectsByName.get(targetParentName);
        const parentSolidWanted = (seedAttachToTarget?.parent_solid) || (seedAttach?.parent_solid) || (parentObjGuess?.userData?.solidName) || null;
        const __getAnchorsForObj = (obj, preferredSolid=null) => {
          const ud = obj?.userData || {};
          const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;
          if (preferredSolid && ab) {
            if (ab[preferredSolid]) return { anchors: ab[preferredSolid], solid: preferredSolid };
            const want = String(preferredSolid).toLowerCase();
            const keys = Object.keys(ab);
            const exactCI = keys.find(k => String(k).toLowerCase() === want);
            if (exactCI && ab[exactCI]) return { anchors: ab[exactCI], solid: exactCI };
            const contains = keys.find(k => String(k).toLowerCase().includes(want) || want.includes(String(k).toLowerCase()));
            if (contains && ab[contains]) return { anchors: ab[contains], solid: contains };
          }
          if (ud.anchors && typeof ud.anchors === "object" && Object.keys(ud.anchors).length) {
            return { anchors: ud.anchors, solid: ud.solidName || null };
          }
          if (!ab) return { anchors: {}, solid: null };
          const solid = (ud.solidName && ab[ud.solidName]) ? ud.solidName : (ab["solid_0"] ? "solid_0" : Object.keys(ab)[0]);
          return { anchors: (solid && ab[solid]) ? ab[solid] : {}, solid: solid || null };
        };
        const parentHit = __getAnchorsForObj(parentObjGuess, parentSolidWanted);
        const anchorsMap = parentHit.anchors || {};

        const seedWorldPos = new THREE.Vector3();
        seedObj.getWorldPosition(seedWorldPos);
        let best = null;
        let bestD = Infinity;
        for (const k of Object.keys(anchorsMap)) {
          const ck = (function(s){
            if (!s) return null;
            const t = String(s).trim().replace(/^hole[ _-]?/i, "").replace(/^anchor[ _-]?/i, "");
            const m = t.match(/^([A-Za-z])[ _-]?(\d{1,4})$/);
            if (!m) return null;
            const L = m[1].toUpperCase();
            const N = parseInt(m[2], 10);
            if (!(L >= "A" && L <= "Z")) return null;
            if (!(N >= 1 && N <= 500)) return null;
            return `${L}${N}`;
          })(k);
          if (!ck) continue;
          const w = __rpAnchorWorldPose(targetParentName, k);
          if (!w || !w.pos) continue;
          const d = w.pos.distanceTo(seedWorldPos);
          if (d < bestD) { bestD = d; best = ck; }
        }
        // Tolerance: ~1mm in your units (mm). If it's farther, it's probably not sitting on a grid anchor.
        if (best && bestD <= 1.0) {
          gridA = __parseGridKey(best);
        }
      } catch (e) {}
    }

    const canGridFill = !!(targetParentName && gridA && gridB);

    // Anchor-based grid fill only (no distance-based XYZ counts)
    if (!seedObj) {
      showToast("Seed object missing.");
      return;
    }
    if (!rp.bAnchor || !rp.bAnchor.ownerName || !rp.bAnchor.anchorName) {
      showToast("Pick the 2nd anchor first.");
      return;
    }
    if (!canGridFill) {
      showToast("Grid fill requires A1-style anchors on the chosen target object.");
      return;
    }

    // Spawn clones of the same type/options as the seed
    // seedObj already resolved above
    const type = seedMeta?.type || seedObj?.userData?.typeName || seedObj?.userData?.componentType || seedObj?.userData?.component;
    if (!type) { showToast("Couldn't determine seed type."); return; }

    // Options for spawn (exclude attach so it spawns free)
    const options = {};
    if (seedMeta) {
      for (const [k,v] of Object.entries(seedMeta)) {
        if (k === "type" || k === "attach") continue;
        options[k] = v;
      }
    }

    // Place instances.
    // If grid-fill applies (seed anchored to same parent as the chosen 2nd anchor AND both anchors look like A1..Z500),
    // we *truly anchor* each new instance to each anchor key in the rectangular range.
    // Otherwise, we fall back to even spacing in XYZ between the two picked world points.

    let spawned = 0;
    if (canGridFill) {
      const parentName = targetParentName;
      const parentObj = objectsByName.get(parentName);
      if (!parentObj) { showToast("Grid fill failed: parent object missing."); return; }

      // Treat the entire fill as one atomic Undo/Redo action.
      const __patternNames = [];
      const __patternSpecs = {};
      const __patternMetas = {};
      // (undo is NOT suspended for this pattern; instances undo one-by-one)
      // IMPORTANT: Use the *same* anchor lookup logic/solid choice that snap() will use.
      // Previously, we built anchorsMap using a potentially different solid than the one
      // passed into __snapChildToParentAnchor(), which caused: we "think" A4 exists, but snap
      // looks in another solid and fails -> objects spawn at the default pose.
                        function __getAnchorsForObj(obj, preferredSolid=null) {
              const ud = obj?.userData || {};
              const ab = (ud.anchorsBySolid && typeof ud.anchorsBySolid === "object") ? ud.anchorsBySolid : null;
              // If UI selected a solid, use that solid's anchors even if ud.anchors exists.
              if (preferredSolid && ab) {
                if (ab[preferredSolid]) return { anchors: ab[preferredSolid], solid: preferredSolid };
                const want = String(preferredSolid).toLowerCase();
                const keys = Object.keys(ab);
                const exactCI = keys.find(k => String(k).toLowerCase() === want);
                if (exactCI && ab[exactCI]) return { anchors: ab[exactCI], solid: exactCI };
                const contains = keys.find(k => String(k).toLowerCase().includes(want) || want.includes(String(k).toLowerCase()));
                if (contains && ab[contains]) return { anchors: ab[contains], solid: contains };
              }
              // Otherwise prefer legacy ud.anchors.
              if (ud.anchors && typeof ud.anchors === "object" && Object.keys(ud.anchors).length) {
                return { anchors: ud.anchors, solid: ud.solidName || null };
              }
              if (!ab) return { anchors: {}, solid: null };
              const solid = (ud.solidName && ab[ud.solidName]) ? ud.solidName : (ab["solid_0"] ? "solid_0" : Object.keys(ab)[0]);
              return { anchors: (solid && ab[solid]) ? ab[solid] : {}, solid: solid || null };
            }



      // Resolve parent anchors + actual solid key once.
      const parentSolidWanted = (seedAttachToTarget?.parent_solid) || (seedAttach?.parent_solid) || (parentObj?.userData?.solidName) || null;
      const parentHit = __getAnchorsForObj(parentObj, parentSolidWanted);
      const anchorsMap = parentHit.anchors || {};
      const parentSolidResolved = parentHit.solid || parentSolidWanted || (parentObj?.userData?.solidName) || "solid_0";

      // Build a canonical->actual key map so we can handle keys like "hole_A4".
      // Canonical form is "A4".
      function __canonGridKey(s) {
        if (!s) return null;
        const t = String(s).trim().replace(/^hole[ _-]?/i, "").replace(/^anchor[ _-]?/i, "");
        const m = t.match(/^([A-Za-z])[ _-]?(\d{1,4})$/);
        if (!m) return null;
        const L = m[1].toUpperCase();
        const N = parseInt(m[2], 10);
        if (!(L >= "A" && L <= "Z")) return null;
        if (!(N >= 1 && N <= 500)) return null;
        return `${L}${N}`;
      }
      const parentKeyByCanon = new Map();
      for (const k of Object.keys(anchorsMap || {})) {
        const ck = __canonGridKey(k);
        if (ck && !parentKeyByCanon.has(ck)) parentKeyByCanon.set(ck, k);
      }

      const c0 = Math.min(gridA.col, gridB.col);
      const c1 = Math.max(gridA.col, gridB.col);
      const r0 = Math.min(gridA.row, gridB.row);
      const r1 = Math.max(gridA.row, gridB.row);

      const childAnchor = (seedAttach?.child_anchor) || (rp.childAnchor) || "center";
      const childSolid = (seedAttach?.child_solid) || (seedObj?.userData?.solidName) || "solid_0";

      // Generate rectangle in row-major order: A1,A2,... then next letter.
      const targets = [];
      for (let col=c0; col<=c1; col++) {
        for (let row=r0; row<=r1; row++) {
          const key = __keyFromCR(col,row);
          if (key === __normGridKey(seedAttachToTarget?.parent_anchor || seedAttach?.parent_anchor)) continue; // skip original
          targets.push(key);
        }
      }

      if (!targets.length) {
        window.builderState.suspendUndo = __prevSuspend;
        showToast("No anchors found in that range on the target object.");
        return;
      }

      showToast(`Grid fill: anchoring ${targets.length} instance(s)…`);

      // Spawn is async (server -> client GLTF load). We must wait until the
      // spawned object exists in objectsByName before snapping, otherwise the
      // instance remains at its default pose (often the middle of the scene)
      // and no attach is persisted.
      async function __waitForObject(name, timeoutMs = 8000) {
        const t0 = performance.now();
        return await new Promise((resolve) => {
          function tick() {
            const obj = objectsByName.get(name);
            if (obj) return resolve(obj);
            if (performance.now() - t0 > timeoutMs) return resolve(null);
            requestAnimationFrame(tick);
          }
          tick();
        });
      }
      for (const parentAnchor of targets) {
        try {
          // Skip anchors that truly don't exist on the resolved parent solid.
          // Accept variants like hole_A4 by canonicalizing keys.
          const actualKey = anchorsMap[parentAnchor] ? parentAnchor : (parentKeyByCanon.get(parentAnchor) || null);
          if (!actualKey) continue;
          // Don't create a duplicate on the seed's own anchor.
          try {
            const seedPA = seedAttachToTarget?.parent_anchor_key || seedAttachToTarget?.parent_anchor || null;
            const seedCanon = __canonGridKey(seedPA);
            if (seedCanon && __canonGridKey(parentAnchor) === seedCanon) continue;
          } catch(e) {}

          const name = await spawnComponentSilent(type, null, options);
          const spawnedObj = await __waitForObject(name);
          if (!spawnedObj) throw new Error(`snap: spawned object not ready (${name})`);
          // Truly anchor using the same UI snap pipeline that manual anchoring uses.
          // This avoids any mismatch between our anchor-resolution code and the live
          // anchor pick/snap path.
          window.builderState.mode = "PICK_TARGET_ANCHOR";
          window.builderState.pending = { name, type, sourceAnchor: childAnchor, childSolid };
          window.builderState.targetName = parentName;
          window.handleAnchorPick(parentName, actualKey);

          // If snapping failed, handleAnchorPick() returns without setting attach.
          const postMeta = window.builderState.components?.[name];
          if (!postMeta?.attach) {
            throw new Error(`snap: failed to attach ${name} to ${parentName}.${actualKey}`);
          }

          // Keep the config clean: store canonical parent anchor (e.g. "A4") even if
          // the underlying CAD key is "hole_A4".
          try {
            const cur = (window.builderState.components && window.builderState.components[name]) ? window.builderState.components[name] : {};
            const at = cur.attach || {};
            const cleanAttach = Object.assign({}, at, {
              parent_name: parentName,
              parent_solid: parentSolidResolved || at.parent_solid,
              parent_anchor: parentAnchor,
              child_solid: childSolid,
              child_anchor: childAnchor,
              offset: [0,0,0,0,0,0]
            });
            window.builderState.components[name] = Object.assign({}, cur, { type: type }, (options||{}), { attach: cleanAttach });
            if (spawnedObj && spawnedObj.userData) spawnedObj.userData.builderAttach = cleanAttach;
            socket.emit("upstream_update", { [name]: { builder: { attach: cleanAttach } } });
          } catch(e) { console.warn("gridfill: attach cleanup failed", e); }

          // Mark pattern lineage so deleting the seed can delete its pattern siblings.
          window.builderState.components[name] = Object.assign({}, window.builderState.components[name]||{}, { patternParent: rp.seedName, patternMode: "GRID_FILL" });
          // capture final spec/meta for redo
          __patternNames.push(name);
          try { __patternSpecs[name] = __deepClone(window.builderState.specs?.[name] || {}); } catch(e) {}
          try { __patternMetas[name] = __deepClone(window.builderState.components?.[name] || {}); } catch(e) {}
          spawned++;
        } catch (e) {
          console.error(e);
          // If we couldn't snap, it's better to stop than to keep dumping parts at origin.
          showToast(String(e?.message || e));
          break;
        }
      }
    } else {
      // Even XYZ spacing (Fusion-like)
      // Treat the entire fill as one atomic Undo/Redo action.
      const __patternNames = [];
      const __patternSpecs = {};
      const __patternMetas = {};
      // (undo is NOT suspended for this pattern; instances undo one-by-one)
      for (let iz=0; iz<nz; iz++) {
        for (let iy=0; iy<ny; iy++) {
          for (let ix=0; ix<nx; ix++) {
            if (ix===0 && iy===0 && iz===0) continue;
            const anchorPos = new THREE.Vector3(
              rp.aAnchor.pos.x + ix*sx,
              rp.aAnchor.pos.y + iy*sy,
              rp.aAnchor.pos.z + iz*sz
            );

            // Maintain the seed object's offset from its attachment anchor.
            const pos = anchorPos.clone().add(rp.seedOffset || new THREE.Vector3());

            try {
              const name = await spawnComponentSilent(type, null, options);
              const obj = objectsByName.get(name);
              if (obj) {
              // Mark this instance as coming from a pattern (used for delete-with-children / debugging).
              window.builderState.components[name] = Object.assign({}, window.builderState.components[name]||{}, { patternParent: rp.seedName, patternMode: "XYZ" });
                obj.quaternion.copy(rp.seedWorldQuat || new THREE.Quaternion());
                socket.emit("upstream_update", { [name]: { pose: [pos.x,pos.y,pos.z,0,0,0] } });
              }
              window.builderState.components[name] = Object.assign({}, window.builderState.components[name]||{}, { patternParent: rp.seedName, patternMode: "XYZ" });
              __patternNames.push(name);
              try { __patternSpecs[name] = __deepClone(window.builderState.specs?.[name] || {}); } catch(e) {}
              try { __patternMetas[name] = __deepClone(window.builderState.components?.[name] || {}); } catch(e) {}
              spawned++;
            } catch (e) {
              console.error(e);
          showToast(String(e?.message || e));
          // Stop so we don't litter the scene with unanchored spawns.
          break;
            }
          }
        }
      }
    }

    showToast(`Patterned ${spawned} instance(s).`);
    closeRectPatternPanel();
  });

  // expose ui refs so click handler can update it
  window.builderState.rectPatternUi = {
    seedBox: seed.box,
    seedClear: seed.clearBtn,
    pointBox: point.box,
    pointClear: point.clearBtn,
    anchorListBtn: btnAnchorList,
    nx: cx.input, ny: cy.input, nz: cz.input,
    hint
  };

  // initial reset
  seed.clearBtn.style.display = "none";
  point.clearBtn.style.display = "none";

  // mount panel
  document.body.appendChild(panel);
}


  </script>

  <!-- Modern minimal bottom-left info bar, hidden by default -->
  <div id="infoBar">
    <span id="infoName"  class="infoLabel"></span>
    <span id="infoType"  class="infoLabel"></span>
    <span id="infoSolid" class="infoLabel"></span>
  </div>

  <style>
    #infoBar {
      position: fixed;
      bottom: 18px;
      left: 22px;
      display: none;             /* hidden until selected */
      font-family: system-ui, sans-serif;
      font-size: 15px;
      font-weight: 600;
      color: #fff;
      padding: 0;
      gap: 0;                     /* boxes connect tightly */
      z-index: 999999;
      background: none;           /* ← remove gray background */
    }

    .infoLabel {
      padding: 6px 14px;
      margin: 0;
      border-radius: 0;           /* ← sharp corners */
      display: inline-block;
      white-space: nowrap;
    }

    /* Sharp, modern colored pills */
    #infoName  { background: #0b3d91; }   /* Blue */
    #infoType  { background: #4d8f00; }   /* Green */
    #infoSolid { background: #8a6d00; }   /* Gold */
  </style>

</body>
</html>
